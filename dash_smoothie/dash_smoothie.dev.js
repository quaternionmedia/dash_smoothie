window["dash_smoothie"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanM/MzIwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/object-assign/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanM/YTE1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsSUFBSSxJQUFxQztBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBNEI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/checkPropTypes.js\n");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n\nvar has = Function.call.bind(Object.prototype.hasOwnProperty);\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/YjA3MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtEQUFVO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTs7QUFFcEMsMkJBQTJCLG1CQUFPLENBQUMseUZBQTRCO0FBQy9ELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjs7QUFFL0M7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVSxLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUMsNEZBQTRGLFNBQU07QUFDN0k7QUFDQTs7QUFFQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prop-types/factoryWithTypeCheckers.js\n");

/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/ZDdiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBVTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsdUZBQTJCO0FBQ3RELENBQUMsTUFBTSxFQUlOIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/index.js\n");

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzU5YjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/prop-types/lib/ReactPropTypesSecret.js\n");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v16.8.6\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n              default:\n                return $$typeof;\n            }\n        }\n      case REACT_LAZY_TYPE:\n      case REACT_MEMO_TYPE:\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\n\n// AsyncMode is deprecated along with isAsyncMode\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\n\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\n\n// AsyncMode should be deprecated\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true;\n      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.typeOf = typeOf;\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isValidElementType = isValidElementType;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz9hOGY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7Ozs7QUFJYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsZUFBZTtBQUMzRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuOC42XG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTtcbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8XG4gIC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSk7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5cbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlO1xuXG4vLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbiAgfSkoKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-is/cjs/react-is.development.js\n");

/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzPzRjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react-is/index.js\n");

/***/ }),

/***/ "./node_modules/react-smoothie/SmoothieComponent.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-smoothie/SmoothieComponent.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar React = __webpack_require__(/*! react */ \"react\");\r\nvar smoothie_1 = __webpack_require__(/*! smoothie */ \"./node_modules/smoothie/smoothie.js\");\r\nexports.TimeSeries = smoothie_1.TimeSeries;\r\nfunction DefaultTooltip(props) {\r\n    if (!props.display)\r\n        return React.createElement(\"div\", null);\r\n    return (React.createElement(\"div\", { style: { userSelect: 'none' } },\r\n        React.createElement(\"strong\", null, props.time),\r\n        props.data ? (React.createElement(\"ul\", null, props.data.map(function (data, i) { return (React.createElement(\"li\", { key: i }, data.value)); }))) : (React.createElement(\"div\", null))));\r\n}\r\nexports.DefaultTooltip = DefaultTooltip;\r\nfunction seriesOptsParser(opts) {\r\n    var ret = {};\r\n    // Get default RGB values\r\n    var R = opts.r, G = opts.g, B = opts.b;\r\n    if (R === undefined)\r\n        R = 0;\r\n    if (G === undefined)\r\n        G = 0;\r\n    if (B === undefined)\r\n        B = 0;\r\n    if (opts.fillStyle === undefined && R + G + B) {\r\n        opts.fillStyle = {};\r\n    }\r\n    if (opts.strokeStyle === undefined && R + G + B) {\r\n        opts.strokeStyle = {};\r\n    }\r\n    Object.entries(opts).forEach(function (_a) {\r\n        var name = _a[0], val = _a[1];\r\n        // Don't copy these to the final return\r\n        switch (name) {\r\n            case 'data':\r\n            case 'r':\r\n            case 'g':\r\n            case 'b':\r\n                return;\r\n            default:\r\n        }\r\n        // Certain values are ready to go\r\n        switch (typeof val) {\r\n            case 'string':\r\n            case 'number':\r\n            case 'boolean':\r\n                ret[name] = val;\r\n                return;\r\n            default:\r\n        }\r\n        // Otherwise we've got an object\r\n        // Only convert our fancy rgba object to a string for supported members\r\n        if (!(name == 'fillStyle' || name == 'strokeStyle')) {\r\n            ret[name] = val;\r\n            return;\r\n        }\r\n        var _b = val, r = _b.r, g = _b.g, b = _b.b, a = _b.a;\r\n        if (r === undefined)\r\n            r = R;\r\n        if (g === undefined)\r\n            g = G;\r\n        if (b === undefined)\r\n            b = B;\r\n        if (a === undefined) {\r\n            a = name == 'strokeStyle' ? 1 : r + g + b ? 0.2 : 0;\r\n        }\r\n        ret[name] = \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + a + \")\";\r\n    });\r\n    return ret;\r\n}\r\nvar SmoothieComponent = /** @class */ (function (_super) {\r\n    __extends(SmoothieComponent, _super);\r\n    function SmoothieComponent(props) {\r\n        var _this = _super.call(this, props) || this;\r\n        _this.state = { tooltip: {} };\r\n        var opts = Object.assign({}, props);\r\n        // SmoothieChart's tooltip injects a div at the end of the page.\r\n        // This will not do. We shall make our own and intercept the data.\r\n        var updateTooltip = function (o) {\r\n            _this.setState(function (state) {\r\n                Object.assign(state.tooltip, o);\r\n                return state;\r\n            });\r\n        };\r\n        opts.tooltipFormatter = function (t, data) {\r\n            updateTooltip({\r\n                time: t,\r\n                data: props.doNotSimplifyData\r\n                    ? data\r\n                    : data.map(function (set) { return ({\r\n                        index: set.index,\r\n                        value: set.value,\r\n                        series: { options: set.series.options },\r\n                    }); }),\r\n            });\r\n            return '';\r\n        };\r\n        // Make boolean for smoothie\r\n        opts.tooltip = !!opts.tooltip;\r\n        var smoothie = new smoothie_1.SmoothieChart(opts);\r\n        var lastDisplay;\r\n        // Intercept the set data\r\n        smoothie.tooltipEl = {\r\n            style: {\r\n                // Intercept when smoothie.js sets tooltipEl.style.display\r\n                set display(v) {\r\n                    if (v === lastDisplay)\r\n                        return;\r\n                    lastDisplay = v;\r\n                    updateTooltip({ display: v == 'block' });\r\n                },\r\n                // Get smoothie's mouse events\r\n                set top(v) {\r\n                    updateTooltip({\r\n                        top: smoothie.mouseY,\r\n                        left: smoothie.mouseX,\r\n                    });\r\n                },\r\n            },\r\n        };\r\n        if (props.series) {\r\n            props.series.forEach(function (series) {\r\n                if (!(series.data instanceof smoothie_1.TimeSeries)) {\r\n                    throw Error('Invalid type passed to series option');\r\n                }\r\n                smoothie.addTimeSeries(series.data, seriesOptsParser(series));\r\n            });\r\n        }\r\n        _this.smoothie = smoothie;\r\n        return _this;\r\n    }\r\n    SmoothieComponent.prototype.componentWillUnmount = function () {\r\n        this.smoothie.stop();\r\n    };\r\n    SmoothieComponent.prototype.render = function () {\r\n        var _this = this;\r\n        var style = {};\r\n        if (this.props.responsive === true) {\r\n            style.width = '100%';\r\n            style.height = this.props.height;\r\n        }\r\n        // Prevent extra pixels in wrapping element\r\n        style.display = 'block';\r\n        style = this.props.style || style;\r\n        var tooltipParentStyle = this.props.tooltipParentStyle || {\r\n            pointerEvents: 'none',\r\n            position: 'absolute',\r\n            left: this.state.tooltip.left,\r\n            top: this.state.tooltip.top,\r\n        };\r\n        var Tooltip = this.props.tooltip;\r\n        if (Tooltip === true) {\r\n            Tooltip = DefaultTooltip;\r\n        }\r\n        var canvas = (React.createElement(\"canvas\", { className: this.props.classNameCanvas || this.props.className, style: style, width: this.props.responsive === true ? undefined : this.props.width, height: this.props.height, ref: function (canv) { return canv && _this.smoothie.streamTo(canv, _this.props.streamDelay); } }));\r\n        var tooltip;\r\n        if (Tooltip) {\r\n            tooltip = (React.createElement(\"div\", { style: tooltipParentStyle, className: this.props.classNameTooltip },\r\n                React.createElement(Tooltip, __assign({}, this.state.tooltip))));\r\n        }\r\n        return (React.createElement(\"div\", { className: this.props.classNameContainer, style: this.props.containerStyle || { position: 'relative' } },\r\n            canvas,\r\n            tooltip));\r\n    };\r\n    SmoothieComponent.prototype.addTimeSeries = function (tsOpts, addOpts) {\r\n        if (addOpts === undefined) {\r\n            addOpts = tsOpts;\r\n            tsOpts = undefined;\r\n        }\r\n        var ts = tsOpts instanceof smoothie_1.TimeSeries ? tsOpts : new smoothie_1.TimeSeries(tsOpts);\r\n        this.smoothie.addTimeSeries(ts, seriesOptsParser(addOpts));\r\n        return ts;\r\n    };\r\n    SmoothieComponent.defaultProps = {\r\n        width: 800,\r\n        height: 200,\r\n        streamDelay: 0,\r\n    };\r\n    return SmoothieComponent;\r\n}(React.Component));\r\nexports.default = SmoothieComponent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNtb290aGllL1Ntb290aGllQ29tcG9uZW50LmpzP2M2NTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxxREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLHFCQUFxQixFQUFFO0FBQ3hFO0FBQ0EseUZBQXlGLG9DQUFvQyxTQUFTLGVBQWUsRUFBRTtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsaUNBQWlDLDhCQUE4QjtBQUMvRCxxQkFBcUIsRUFBRSxFQUFFO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxTUFBcU0sdUVBQXVFLEVBQUUsRUFBRTtBQUNyVTtBQUNBO0FBQ0EsbURBQW1ELG9FQUFvRTtBQUN2SCx3REFBd0Q7QUFDeEQ7QUFDQSw0Q0FBNEMsZ0ZBQWdGLHVCQUF1QixFQUFFO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZWFjdC1zbW9vdGhpZS9TbW9vdGhpZUNvbXBvbmVudC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxyXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIHNtb290aGllXzEgPSByZXF1aXJlKFwic21vb3RoaWVcIik7XHJcbmV4cG9ydHMuVGltZVNlcmllcyA9IHNtb290aGllXzEuVGltZVNlcmllcztcclxuZnVuY3Rpb24gRGVmYXVsdFRvb2x0aXAocHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMuZGlzcGxheSlcclxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKTtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHVzZXJTZWxlY3Q6ICdub25lJyB9IH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0cm9uZ1wiLCBudWxsLCBwcm9wcy50aW1lKSxcclxuICAgICAgICBwcm9wcy5kYXRhID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCBudWxsLCBwcm9wcy5kYXRhLm1hcChmdW5jdGlvbiAoZGF0YSwgaSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IGtleTogaSB9LCBkYXRhLnZhbHVlKSk7IH0pKSkgOiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKSkpKTtcclxufVxyXG5leHBvcnRzLkRlZmF1bHRUb29sdGlwID0gRGVmYXVsdFRvb2x0aXA7XHJcbmZ1bmN0aW9uIHNlcmllc09wdHNQYXJzZXIob3B0cykge1xyXG4gICAgdmFyIHJldCA9IHt9O1xyXG4gICAgLy8gR2V0IGRlZmF1bHQgUkdCIHZhbHVlc1xyXG4gICAgdmFyIFIgPSBvcHRzLnIsIEcgPSBvcHRzLmcsIEIgPSBvcHRzLmI7XHJcbiAgICBpZiAoUiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIFIgPSAwO1xyXG4gICAgaWYgKEcgPT09IHVuZGVmaW5lZClcclxuICAgICAgICBHID0gMDtcclxuICAgIGlmIChCID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgQiA9IDA7XHJcbiAgICBpZiAob3B0cy5maWxsU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBSICsgRyArIEIpIHtcclxuICAgICAgICBvcHRzLmZpbGxTdHlsZSA9IHt9O1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMuc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCAmJiBSICsgRyArIEIpIHtcclxuICAgICAgICBvcHRzLnN0cm9rZVN0eWxlID0ge307XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZW50cmllcyhvcHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBuYW1lID0gX2FbMF0sIHZhbCA9IF9hWzFdO1xyXG4gICAgICAgIC8vIERvbid0IGNvcHkgdGhlc2UgdG8gdGhlIGZpbmFsIHJldHVyblxyXG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlICdkYXRhJzpcclxuICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2cnOlxyXG4gICAgICAgICAgICBjYXNlICdiJzpcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2VydGFpbiB2YWx1ZXMgYXJlIHJlYWR5IHRvIGdvXHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgICAgICAgcmV0W25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UndmUgZ290IGFuIG9iamVjdFxyXG4gICAgICAgIC8vIE9ubHkgY29udmVydCBvdXIgZmFuY3kgcmdiYSBvYmplY3QgdG8gYSBzdHJpbmcgZm9yIHN1cHBvcnRlZCBtZW1iZXJzXHJcbiAgICAgICAgaWYgKCEobmFtZSA9PSAnZmlsbFN0eWxlJyB8fCBuYW1lID09ICdzdHJva2VTdHlsZScpKSB7XHJcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2IgPSB2YWwsIHIgPSBfYi5yLCBnID0gX2IuZywgYiA9IF9iLmIsIGEgPSBfYi5hO1xyXG4gICAgICAgIGlmIChyID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHIgPSBSO1xyXG4gICAgICAgIGlmIChnID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGcgPSBHO1xyXG4gICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIGIgPSBCO1xyXG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgYSA9IG5hbWUgPT0gJ3N0cm9rZVN0eWxlJyA/IDEgOiByICsgZyArIGIgPyAwLjIgOiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXRbbmFtZV0gPSBcInJnYmEoXCIgKyByICsgXCIsXCIgKyBnICsgXCIsXCIgKyBiICsgXCIsXCIgKyBhICsgXCIpXCI7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxudmFyIFNtb290aGllQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNtb290aGllQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU21vb3RoaWVDb21wb25lbnQocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHsgdG9vbHRpcDoge30gfTtcclxuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKTtcclxuICAgICAgICAvLyBTbW9vdGhpZUNoYXJ0J3MgdG9vbHRpcCBpbmplY3RzIGEgZGl2IGF0IHRoZSBlbmQgb2YgdGhlIHBhZ2UuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIG5vdCBkby4gV2Ugc2hhbGwgbWFrZSBvdXIgb3duIGFuZCBpbnRlcmNlcHQgdGhlIGRhdGEuXHJcbiAgICAgICAgdmFyIHVwZGF0ZVRvb2x0aXAgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUudG9vbHRpcCwgbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb3B0cy50b29sdGlwRm9ybWF0dGVyID0gZnVuY3Rpb24gKHQsIGRhdGEpIHtcclxuICAgICAgICAgICAgdXBkYXRlVG9vbHRpcCh7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiB0LFxyXG4gICAgICAgICAgICAgICAgZGF0YTogcHJvcHMuZG9Ob3RTaW1wbGlmeURhdGFcclxuICAgICAgICAgICAgICAgICAgICA/IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICA6IGRhdGEubWFwKGZ1bmN0aW9uIChzZXQpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBzZXQuaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZXQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogeyBvcHRpb25zOiBzZXQuc2VyaWVzLm9wdGlvbnMgfSxcclxuICAgICAgICAgICAgICAgICAgICB9KTsgfSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBNYWtlIGJvb2xlYW4gZm9yIHNtb290aGllXHJcbiAgICAgICAgb3B0cy50b29sdGlwID0gISFvcHRzLnRvb2x0aXA7XHJcbiAgICAgICAgdmFyIHNtb290aGllID0gbmV3IHNtb290aGllXzEuU21vb3RoaWVDaGFydChvcHRzKTtcclxuICAgICAgICB2YXIgbGFzdERpc3BsYXk7XHJcbiAgICAgICAgLy8gSW50ZXJjZXB0IHRoZSBzZXQgZGF0YVxyXG4gICAgICAgIHNtb290aGllLnRvb2x0aXBFbCA9IHtcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIC8vIEludGVyY2VwdCB3aGVuIHNtb290aGllLmpzIHNldHMgdG9vbHRpcEVsLnN0eWxlLmRpc3BsYXlcclxuICAgICAgICAgICAgICAgIHNldCBkaXNwbGF5KHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gbGFzdERpc3BsYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlzcGxheSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVG9vbHRpcCh7IGRpc3BsYXk6IHYgPT0gJ2Jsb2NrJyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgc21vb3RoaWUncyBtb3VzZSBldmVudHNcclxuICAgICAgICAgICAgICAgIHNldCB0b3Aodikge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRvb2x0aXAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHNtb290aGllLm1vdXNlWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc21vb3RoaWUubW91c2VYLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChwcm9wcy5zZXJpZXMpIHtcclxuICAgICAgICAgICAgcHJvcHMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24gKHNlcmllcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoc2VyaWVzLmRhdGEgaW5zdGFuY2VvZiBzbW9vdGhpZV8xLlRpbWVTZXJpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgdHlwZSBwYXNzZWQgdG8gc2VyaWVzIG9wdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc21vb3RoaWUuYWRkVGltZVNlcmllcyhzZXJpZXMuZGF0YSwgc2VyaWVzT3B0c1BhcnNlcihzZXJpZXMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnNtb290aGllID0gc21vb3RoaWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgU21vb3RoaWVDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc21vb3RoaWUuc3RvcCgpO1xyXG4gICAgfTtcclxuICAgIFNtb290aGllQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc3R5bGUgPSB7fTtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5yZXNwb25zaXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSB0aGlzLnByb3BzLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJldmVudCBleHRyYSBwaXhlbHMgaW4gd3JhcHBpbmcgZWxlbWVudFxyXG4gICAgICAgIHN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIHN0eWxlID0gdGhpcy5wcm9wcy5zdHlsZSB8fCBzdHlsZTtcclxuICAgICAgICB2YXIgdG9vbHRpcFBhcmVudFN0eWxlID0gdGhpcy5wcm9wcy50b29sdGlwUGFyZW50U3R5bGUgfHwge1xyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnN0YXRlLnRvb2x0aXAubGVmdCxcclxuICAgICAgICAgICAgdG9wOiB0aGlzLnN0YXRlLnRvb2x0aXAudG9wLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIFRvb2x0aXAgPSB0aGlzLnByb3BzLnRvb2x0aXA7XHJcbiAgICAgICAgaWYgKFRvb2x0aXAgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgVG9vbHRpcCA9IERlZmF1bHRUb29sdGlwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FudmFzID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgeyBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lQ2FudmFzIHx8IHRoaXMucHJvcHMuY2xhc3NOYW1lLCBzdHlsZTogc3R5bGUsIHdpZHRoOiB0aGlzLnByb3BzLnJlc3BvbnNpdmUgPT09IHRydWUgPyB1bmRlZmluZWQgOiB0aGlzLnByb3BzLndpZHRoLCBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0LCByZWY6IGZ1bmN0aW9uIChjYW52KSB7IHJldHVybiBjYW52ICYmIF90aGlzLnNtb290aGllLnN0cmVhbVRvKGNhbnYsIF90aGlzLnByb3BzLnN0cmVhbURlbGF5KTsgfSB9KSk7XHJcbiAgICAgICAgdmFyIHRvb2x0aXA7XHJcbiAgICAgICAgaWYgKFRvb2x0aXApIHtcclxuICAgICAgICAgICAgdG9vbHRpcCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHRvb2x0aXBQYXJlbnRTdHlsZSwgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZVRvb2x0aXAgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVG9vbHRpcCwgX19hc3NpZ24oe30sIHRoaXMuc3RhdGUudG9vbHRpcCkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWVDb250YWluZXIsIHN0eWxlOiB0aGlzLnByb3BzLmNvbnRhaW5lclN0eWxlIHx8IHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSB9LFxyXG4gICAgICAgICAgICBjYW52YXMsXHJcbiAgICAgICAgICAgIHRvb2x0aXApKTtcclxuICAgIH07XHJcbiAgICBTbW9vdGhpZUNvbXBvbmVudC5wcm90b3R5cGUuYWRkVGltZVNlcmllcyA9IGZ1bmN0aW9uICh0c09wdHMsIGFkZE9wdHMpIHtcclxuICAgICAgICBpZiAoYWRkT3B0cyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGFkZE9wdHMgPSB0c09wdHM7XHJcbiAgICAgICAgICAgIHRzT3B0cyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRzID0gdHNPcHRzIGluc3RhbmNlb2Ygc21vb3RoaWVfMS5UaW1lU2VyaWVzID8gdHNPcHRzIDogbmV3IHNtb290aGllXzEuVGltZVNlcmllcyh0c09wdHMpO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaWUuYWRkVGltZVNlcmllcyh0cywgc2VyaWVzT3B0c1BhcnNlcihhZGRPcHRzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRzO1xyXG4gICAgfTtcclxuICAgIFNtb290aGllQ29tcG9uZW50LmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICB3aWR0aDogODAwLFxyXG4gICAgICAgIGhlaWdodDogMjAwLFxyXG4gICAgICAgIHN0cmVhbURlbGF5OiAwLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBTbW9vdGhpZUNvbXBvbmVudDtcclxufShSZWFjdC5Db21wb25lbnQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU21vb3RoaWVDb21wb25lbnQ7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-smoothie/SmoothieComponent.js\n");

/***/ }),

/***/ "./node_modules/smoothie/smoothie.js":
/*!*******************************************!*\
  !*** ./node_modules/smoothie/smoothie.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// MIT License:\n//\n// Copyright (c) 2010-2013, Joe Walnes\n//               2013-2018, Drew Noakes\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Smoothie Charts - http://smoothiecharts.org/\n * (c) 2010-2013, Joe Walnes\n *     2013-2018, Drew Noakes\n *\n * v1.0: Main charting library, by Joe Walnes\n * v1.1: Auto scaling of axis, by Neil Dunn\n * v1.2: fps (frames per second) option, by Mathias Petterson\n * v1.3: Fix for divide by zero, by Paul Nikitochkin\n * v1.4: Set minimum, top-scale padding, remove timeseries, add optional timer to reset bounds, by Kelley Reynolds\n * v1.5: Set default frames per second to 50... smoother.\n *       .start(), .stop() methods for conserving CPU, by Dmitry Vyal\n *       options.interpolation = 'bezier' or 'line', by Dmitry Vyal\n *       options.maxValue to fix scale, by Dmitry Vyal\n * v1.6: minValue/maxValue will always get converted to floats, by Przemek Matylla\n * v1.7: options.grid.fillStyle may be a transparent color, by Dmitry A. Shashkin\n *       Smooth rescaling, by Kostas Michalopoulos\n * v1.8: Set max length to customize number of live points in the dataset with options.maxDataSetLength, by Krishna Narni\n * v1.9: Display timestamps along the bottom, by Nick and Stev-io\n *       (https://groups.google.com/forum/?fromgroups#!topic/smoothie-charts/-Ywse8FCpKI%5B1-25%5D)\n *       Refactored by Krishna Narni, to support timestamp formatting function\n * v1.10: Switch to requestAnimationFrame, removed the now obsoleted options.fps, by Gergely Imreh\n * v1.11: options.grid.sharpLines option added, by @drewnoakes\n *        Addressed warning seen in Firefox when seriesOption.fillStyle undefined, by @drewnoakes\n * v1.12: Support for horizontalLines added, by @drewnoakes\n *        Support for yRangeFunction callback added, by @drewnoakes\n * v1.13: Fixed typo (#32), by @alnikitich\n * v1.14: Timer cleared when last TimeSeries removed (#23), by @davidgaleano\n *        Fixed diagonal line on chart at start/end of data stream, by @drewnoakes\n * v1.15: Support for npm package (#18), by @dominictarr\n *        Fixed broken removeTimeSeries function (#24) by @davidgaleano\n *        Minor performance and tidying, by @drewnoakes\n * v1.16: Bug fix introduced in v1.14 relating to timer creation/clearance (#23), by @drewnoakes\n *        TimeSeries.append now deals with out-of-order timestamps, and can merge duplicates, by @zacwitte (#12)\n *        Documentation and some local variable renaming for clarity, by @drewnoakes\n * v1.17: Allow control over font size (#10), by @drewnoakes\n *        Timestamp text won't overlap, by @drewnoakes\n * v1.18: Allow control of max/min label precision, by @drewnoakes\n *        Added 'borderVisible' chart option, by @drewnoakes\n *        Allow drawing series with fill but no stroke (line), by @drewnoakes\n * v1.19: Avoid unnecessary repaints, and fixed flicker in old browsers having multiple charts in document (#40), by @asbai\n * v1.20: Add SmoothieChart.getTimeSeriesOptions and SmoothieChart.bringToFront functions, by @drewnoakes\n * v1.21: Add 'step' interpolation mode, by @drewnoakes\n * v1.22: Add support for different pixel ratios. Also add optional y limit formatters, by @copacetic\n * v1.23: Fix bug introduced in v1.22 (#44), by @drewnoakes\n * v1.24: Fix bug introduced in v1.23, re-adding parseFloat to y-axis formatter defaults, by @siggy_sf\n * v1.25: Fix bug seen when adding a data point to TimeSeries which is older than the current data, by @Nking92\n *        Draw time labels on top of series, by @comolosabia\n *        Add TimeSeries.clear function, by @drewnoakes\n * v1.26: Add support for resizing on high device pixel ratio screens, by @copacetic\n * v1.27: Fix bug introduced in v1.26 for non whole number devicePixelRatio values, by @zmbush\n * v1.28: Add 'minValueScale' option, by @megawac\n *        Fix 'labelPos' for different size of 'minValueString' 'maxValueString', by @henryn\n * v1.29: Support responsive sizing, by @drewnoakes\n * v1.29.1: Include types in package, and make property optional, by @TrentHouliston\n * v1.30: Fix inverted logic in devicePixelRatio support, by @scanlime\n * v1.31: Support tooltips, by @Sly1024 and @drewnoakes\n * v1.32: Support frame rate limit, by @dpuyosa\n * v1.33: Use Date static method instead of instance, by @nnnoel\n *        Fix bug with tooltips when multiple charts on a page, by @jpmbiz70\n * v1.34: Add disabled option to TimeSeries, by @TechGuard (#91)\n *        Add nonRealtimeData option, by @annazhelt (#92, #93)\n *        Add showIntermediateLabels option, by @annazhelt (#94)\n *        Add displayDataFromPercentile option, by @annazhelt (#95)\n *        Fix bug when hiding tooltip element, by @ralphwetzel (#96)\n *        Support intermediate y-axis labels, by @beikeland (#99)\n * v1.35: Fix issue with responsive mode at high DPI, by @drewnoakes (#101)\n */\n\n;(function(exports) {\n\n  // Date.now polyfill\n  Date.now = Date.now || function() { return new Date().getTime(); };\n\n  var Util = {\n    extend: function() {\n      arguments[0] = arguments[0] || {};\n      for (var i = 1; i < arguments.length; i++)\n      {\n        for (var key in arguments[i])\n        {\n          if (arguments[i].hasOwnProperty(key))\n          {\n            if (typeof(arguments[i][key]) === 'object') {\n              if (arguments[i][key] instanceof Array) {\n                arguments[0][key] = arguments[i][key];\n              } else {\n                arguments[0][key] = Util.extend(arguments[0][key], arguments[i][key]);\n              }\n            } else {\n              arguments[0][key] = arguments[i][key];\n            }\n          }\n        }\n      }\n      return arguments[0];\n    },\n    binarySearch: function(data, value) {\n      var low = 0,\n          high = data.length;\n      while (low < high) {\n        var mid = (low + high) >> 1;\n        if (value < data[mid][0])\n          high = mid;\n        else\n          low = mid + 1;\n      }\n      return low;\n    }\n  };\n\n  /**\n   * Initialises a new <code>TimeSeries</code> with optional data options.\n   *\n   * Options are of the form (defaults shown):\n   *\n   * <pre>\n   * {\n   *   resetBounds: true,        // enables/disables automatic scaling of the y-axis\n   *   resetBoundsInterval: 3000 // the period between scaling calculations, in millis\n   * }\n   * </pre>\n   *\n   * Presentation options for TimeSeries are specified as an argument to <code>SmoothieChart.addTimeSeries</code>.\n   *\n   * @constructor\n   */\n  function TimeSeries(options) {\n    this.options = Util.extend({}, TimeSeries.defaultOptions, options);\n    this.disabled = false;\n    this.clear();\n  }\n\n  TimeSeries.defaultOptions = {\n    resetBoundsInterval: 3000,\n    resetBounds: true\n  };\n\n  /**\n   * Clears all data and state from this TimeSeries object.\n   */\n  TimeSeries.prototype.clear = function() {\n    this.data = [];\n    this.maxValue = Number.NaN; // The maximum value ever seen in this TimeSeries.\n    this.minValue = Number.NaN; // The minimum value ever seen in this TimeSeries.\n  };\n\n  /**\n   * Recalculate the min/max values for this <code>TimeSeries</code> object.\n   *\n   * This causes the graph to scale itself in the y-axis.\n   */\n  TimeSeries.prototype.resetBounds = function() {\n    if (this.data.length) {\n      // Walk through all data points, finding the min/max value\n      this.maxValue = this.data[0][1];\n      this.minValue = this.data[0][1];\n      for (var i = 1; i < this.data.length; i++) {\n        var value = this.data[i][1];\n        if (value > this.maxValue) {\n          this.maxValue = value;\n        }\n        if (value < this.minValue) {\n          this.minValue = value;\n        }\n      }\n    } else {\n      // No data exists, so set min/max to NaN\n      this.maxValue = Number.NaN;\n      this.minValue = Number.NaN;\n    }\n  };\n\n  /**\n   * Adds a new data point to the <code>TimeSeries</code>, preserving chronological order.\n   *\n   * @param timestamp the position, in time, of this data point\n   * @param value the value of this data point\n   * @param sumRepeatedTimeStampValues if <code>timestamp</code> has an exact match in the series, this flag controls\n   * whether it is replaced, or the values summed (defaults to false.)\n   */\n  TimeSeries.prototype.append = function(timestamp, value, sumRepeatedTimeStampValues) {\n    // Rewind until we hit an older timestamp\n    var i = this.data.length - 1;\n    while (i >= 0 && this.data[i][0] > timestamp) {\n      i--;\n    }\n\n    if (i === -1) {\n      // This new item is the oldest data\n      this.data.splice(0, 0, [timestamp, value]);\n    } else if (this.data.length > 0 && this.data[i][0] === timestamp) {\n      // Update existing values in the array\n      if (sumRepeatedTimeStampValues) {\n        // Sum this value into the existing 'bucket'\n        this.data[i][1] += value;\n        value = this.data[i][1];\n      } else {\n        // Replace the previous value\n        this.data[i][1] = value;\n      }\n    } else if (i < this.data.length - 1) {\n      // Splice into the correct position to keep timestamps in order\n      this.data.splice(i + 1, 0, [timestamp, value]);\n    } else {\n      // Add to the end of the array\n      this.data.push([timestamp, value]);\n    }\n\n    this.maxValue = isNaN(this.maxValue) ? value : Math.max(this.maxValue, value);\n    this.minValue = isNaN(this.minValue) ? value : Math.min(this.minValue, value);\n  };\n\n  TimeSeries.prototype.dropOldData = function(oldestValidTime, maxDataSetLength) {\n    // We must always keep one expired data point as we need this to draw the\n    // line that comes into the chart from the left, but any points prior to that can be removed.\n    var removeCount = 0;\n    while (this.data.length - removeCount >= maxDataSetLength && this.data[removeCount + 1][0] < oldestValidTime) {\n      removeCount++;\n    }\n    if (removeCount !== 0) {\n      this.data.splice(0, removeCount);\n    }\n  };\n\n  /**\n   * Initialises a new <code>SmoothieChart</code>.\n   *\n   * Options are optional, and should be of the form below. Just specify the values you\n   * need and the rest will be given sensible defaults as shown:\n   *\n   * <pre>\n   * {\n   *   minValue: undefined,                      // specify to clamp the lower y-axis to a given value\n   *   maxValue: undefined,                      // specify to clamp the upper y-axis to a given value\n   *   maxValueScale: 1,                         // allows proportional padding to be added above the chart. for 10% padding, specify 1.1.\n   *   minValueScale: 1,                         // allows proportional padding to be added below the chart. for 10% padding, specify 1.1.\n   *   yRangeFunction: undefined,                // function({min: , max: }) { return {min: , max: }; }\n   *   scaleSmoothing: 0.125,                    // controls the rate at which y-value zoom animation occurs\n   *   millisPerPixel: 20,                       // sets the speed at which the chart pans by\n   *   enableDpiScaling: true,                   // support rendering at different DPI depending on the device\n   *   yMinFormatter: function(min, precision) { // callback function that formats the min y value label\n   *     return parseFloat(min).toFixed(precision);\n   *   },\n   *   yMaxFormatter: function(max, precision) { // callback function that formats the max y value label\n   *     return parseFloat(max).toFixed(precision);\n   *   },\n   *   yIntermediateFormatter: function(intermediate, precision) { // callback function that formats the intermediate y value labels\n   *     return parseFloat(intermediate).toFixed(precision);\n   *   },\n   *   maxDataSetLength: 2,\n   *   interpolation: 'bezier'                   // one of 'bezier', 'linear', or 'step'\n   *   timestampFormatter: null,                 // optional function to format time stamps for bottom of chart\n   *                                             // you may use SmoothieChart.timeFormatter, or your own: function(date) { return ''; }\n   *   scrollBackwards: false,                   // reverse the scroll direction of the chart\n   *   horizontalLines: [],                      // [ { value: 0, color: '#ffffff', lineWidth: 1 } ]\n   *   grid:\n   *   {\n   *     fillStyle: '#000000',                   // the background colour of the chart\n   *     lineWidth: 1,                           // the pixel width of grid lines\n   *     strokeStyle: '#777777',                 // colour of grid lines\n   *     millisPerLine: 1000,                    // distance between vertical grid lines\n   *     sharpLines: false,                      // controls whether grid lines are 1px sharp, or softened\n   *     verticalSections: 2,                    // number of vertical sections marked out by horizontal grid lines\n   *     borderVisible: true                     // whether the grid lines trace the border of the chart or not\n   *   },\n   *   labels\n   *   {\n   *     disabled: false,                        // enables/disables labels showing the min/max values\n   *     fillStyle: '#ffffff',                   // colour for text of labels,\n   *     fontSize: 15,\n   *     fontFamily: 'sans-serif',\n   *     precision: 2,\n   *     showIntermediateLabels: false,          // shows intermediate labels between min and max values along y axis\n   *     intermediateLabelSameAxis: true,\n   *   },\n   *   tooltip: false                            // show tooltip when mouse is over the chart\n   *   tooltipLine: {                            // properties for a vertical line at the cursor position\n   *     lineWidth: 1,\n   *     strokeStyle: '#BBBBBB'\n   *   },\n   *   tooltipFormatter: SmoothieChart.tooltipFormatter, // formatter function for tooltip text\n   *   nonRealtimeData: false,                   // use time of latest data as current time\n   *   displayDataFromPercentile: 1,             // display not latest data, but data from the given percentile\n   *                                             // useful when trying to see old data saved by setting a high value for maxDataSetLength\n   *                                             // should be a value between 0 and 1\n   *   responsive: false,                        // whether the chart should adapt to the size of the canvas\n   *   limitFPS: 0                               // maximum frame rate the chart will render at, in FPS (zero means no limit)\n   * }\n   * </pre>\n   *\n   * @constructor\n   */\n  function SmoothieChart(options) {\n    this.options = Util.extend({}, SmoothieChart.defaultChartOptions, options);\n    this.seriesSet = [];\n    this.currentValueRange = 1;\n    this.currentVisMinValue = 0;\n    this.lastRenderTimeMillis = 0;\n    this.lastChartTimestamp = 0;\n\n    this.mousemove = this.mousemove.bind(this);\n    this.mouseout = this.mouseout.bind(this);\n  }\n\n  /** Formats the HTML string content of the tooltip. */\n  SmoothieChart.tooltipFormatter = function (timestamp, data) {\n      var timestampFormatter = this.options.timestampFormatter || SmoothieChart.timeFormatter,\n          lines = [timestampFormatter(new Date(timestamp))];\n\n      for (var i = 0; i < data.length; ++i) {\n        lines.push('<span style=\"color:' + data[i].series.options.strokeStyle + '\">' +\n        this.options.yMaxFormatter(data[i].value, this.options.labels.precision) + '</span>');\n      }\n\n      return lines.join('<br>');\n  };\n\n  SmoothieChart.defaultChartOptions = {\n    millisPerPixel: 20,\n    enableDpiScaling: true,\n    yMinFormatter: function(min, precision) {\n      return parseFloat(min).toFixed(precision);\n    },\n    yMaxFormatter: function(max, precision) {\n      return parseFloat(max).toFixed(precision);\n    },\n    yIntermediateFormatter: function(intermediate, precision) {\n      return parseFloat(intermediate).toFixed(precision);\n    },\n    maxValueScale: 1,\n    minValueScale: 1,\n    interpolation: 'bezier',\n    scaleSmoothing: 0.125,\n    maxDataSetLength: 2,\n    scrollBackwards: false,\n    displayDataFromPercentile: 1,\n    grid: {\n      fillStyle: '#000000',\n      strokeStyle: '#777777',\n      lineWidth: 1,\n      sharpLines: false,\n      millisPerLine: 1000,\n      verticalSections: 2,\n      borderVisible: true\n    },\n    labels: {\n      fillStyle: '#ffffff',\n      disabled: false,\n      fontSize: 10,\n      fontFamily: 'monospace',\n      precision: 2,\n      showIntermediateLabels: false,\n      intermediateLabelSameAxis: true,\n    },\n    horizontalLines: [],\n    tooltip: false,\n    tooltipLine: {\n      lineWidth: 1,\n      strokeStyle: '#BBBBBB'\n    },\n    tooltipFormatter: SmoothieChart.tooltipFormatter,\n    nonRealtimeData: false,\n    responsive: false,\n    limitFPS: 0\n  };\n\n  // Based on http://inspirit.github.com/jsfeat/js/compatibility.js\n  SmoothieChart.AnimateCompatibility = (function() {\n    var requestAnimationFrame = function(callback, element) {\n          var requestAnimationFrame =\n            window.requestAnimationFrame        ||\n            window.webkitRequestAnimationFrame  ||\n            window.mozRequestAnimationFrame     ||\n            window.oRequestAnimationFrame       ||\n            window.msRequestAnimationFrame      ||\n            function(callback) {\n              return window.setTimeout(function() {\n                callback(Date.now());\n              }, 16);\n            };\n          return requestAnimationFrame.call(window, callback, element);\n        },\n        cancelAnimationFrame = function(id) {\n          var cancelAnimationFrame =\n            window.cancelAnimationFrame ||\n            function(id) {\n              clearTimeout(id);\n            };\n          return cancelAnimationFrame.call(window, id);\n        };\n\n    return {\n      requestAnimationFrame: requestAnimationFrame,\n      cancelAnimationFrame: cancelAnimationFrame\n    };\n  })();\n\n  SmoothieChart.defaultSeriesPresentationOptions = {\n    lineWidth: 1,\n    strokeStyle: '#ffffff'\n  };\n\n  /**\n   * Adds a <code>TimeSeries</code> to this chart, with optional presentation options.\n   *\n   * Presentation options should be of the form (defaults shown):\n   *\n   * <pre>\n   * {\n   *   lineWidth: 1,\n   *   strokeStyle: '#ffffff',\n   *   fillStyle: undefined\n   * }\n   * </pre>\n   */\n  SmoothieChart.prototype.addTimeSeries = function(timeSeries, options) {\n    this.seriesSet.push({timeSeries: timeSeries, options: Util.extend({}, SmoothieChart.defaultSeriesPresentationOptions, options)});\n    if (timeSeries.options.resetBounds && timeSeries.options.resetBoundsInterval > 0) {\n      timeSeries.resetBoundsTimerId = setInterval(\n        function() {\n          timeSeries.resetBounds();\n        },\n        timeSeries.options.resetBoundsInterval\n      );\n    }\n  };\n\n  /**\n   * Removes the specified <code>TimeSeries</code> from the chart.\n   */\n  SmoothieChart.prototype.removeTimeSeries = function(timeSeries) {\n    // Find the correct timeseries to remove, and remove it\n    var numSeries = this.seriesSet.length;\n    for (var i = 0; i < numSeries; i++) {\n      if (this.seriesSet[i].timeSeries === timeSeries) {\n        this.seriesSet.splice(i, 1);\n        break;\n      }\n    }\n    // If a timer was operating for that timeseries, remove it\n    if (timeSeries.resetBoundsTimerId) {\n      // Stop resetting the bounds, if we were\n      clearInterval(timeSeries.resetBoundsTimerId);\n    }\n  };\n\n  /**\n   * Gets render options for the specified <code>TimeSeries</code>.\n   *\n   * As you may use a single <code>TimeSeries</code> in multiple charts with different formatting in each usage,\n   * these settings are stored in the chart.\n   */\n  SmoothieChart.prototype.getTimeSeriesOptions = function(timeSeries) {\n    // Find the correct timeseries to remove, and remove it\n    var numSeries = this.seriesSet.length;\n    for (var i = 0; i < numSeries; i++) {\n      if (this.seriesSet[i].timeSeries === timeSeries) {\n        return this.seriesSet[i].options;\n      }\n    }\n  };\n\n  /**\n   * Brings the specified <code>TimeSeries</code> to the top of the chart. It will be rendered last.\n   */\n  SmoothieChart.prototype.bringToFront = function(timeSeries) {\n    // Find the correct timeseries to remove, and remove it\n    var numSeries = this.seriesSet.length;\n    for (var i = 0; i < numSeries; i++) {\n      if (this.seriesSet[i].timeSeries === timeSeries) {\n        var set = this.seriesSet.splice(i, 1);\n        this.seriesSet.push(set[0]);\n        break;\n      }\n    }\n  };\n\n  /**\n   * Instructs the <code>SmoothieChart</code> to start rendering to the provided canvas, with specified delay.\n   *\n   * @param canvas the target canvas element\n   * @param delayMillis an amount of time to wait before a data point is shown. This can prevent the end of the series\n   * from appearing on screen, with new values flashing into view, at the expense of some latency.\n   */\n  SmoothieChart.prototype.streamTo = function(canvas, delayMillis) {\n    this.canvas = canvas;\n    this.delay = delayMillis;\n    this.start();\n  };\n\n  SmoothieChart.prototype.getTooltipEl = function () {\n    // Create the tool tip element lazily\n    if (!this.tooltipEl) {\n      this.tooltipEl = document.createElement('div');\n      this.tooltipEl.className = 'smoothie-chart-tooltip';\n      this.tooltipEl.style.position = 'absolute';\n      this.tooltipEl.style.display = 'none';\n      document.body.appendChild(this.tooltipEl);\n    }\n    return this.tooltipEl;\n  };\n\n  SmoothieChart.prototype.updateTooltip = function () {\n    var el = this.getTooltipEl();\n\n    if (!this.mouseover || !this.options.tooltip) {\n      el.style.display = 'none';\n      return;\n    }\n\n    var time = this.lastChartTimestamp;\n\n    // x pixel to time\n    var t = this.options.scrollBackwards\n      ? time - this.mouseX * this.options.millisPerPixel\n      : time - (this.canvas.offsetWidth - this.mouseX) * this.options.millisPerPixel;\n\n    var data = [];\n\n     // For each data set...\n    for (var d = 0; d < this.seriesSet.length; d++) {\n      var timeSeries = this.seriesSet[d].timeSeries;\n      if (timeSeries.disabled) {\n          continue;\n      }\n\n      // find datapoint closest to time 't'\n      var closeIdx = Util.binarySearch(timeSeries.data, t);\n      if (closeIdx > 0 && closeIdx < timeSeries.data.length) {\n        data.push({ series: this.seriesSet[d], index: closeIdx, value: timeSeries.data[closeIdx][1] });\n      }\n    }\n\n    if (data.length) {\n      el.innerHTML = this.options.tooltipFormatter.call(this, t, data);\n      el.style.display = 'block';\n    } else {\n      el.style.display = 'none';\n    }\n  };\n\n  SmoothieChart.prototype.mousemove = function (evt) {\n    this.mouseover = true;\n    this.mouseX = evt.offsetX;\n    this.mouseY = evt.offsetY;\n    this.mousePageX = evt.pageX;\n    this.mousePageY = evt.pageY;\n\n    var el = this.getTooltipEl();\n    el.style.top = Math.round(this.mousePageY) + 'px';\n    el.style.left = Math.round(this.mousePageX) + 'px';\n    this.updateTooltip();\n  };\n\n  SmoothieChart.prototype.mouseout = function () {\n    this.mouseover = false;\n    this.mouseX = this.mouseY = -1;\n    if (this.tooltipEl)\n      this.tooltipEl.style.display = 'none';\n  };\n\n  /**\n   * Make sure the canvas has the optimal resolution for the device's pixel ratio.\n   */\n  SmoothieChart.prototype.resize = function () {\n    var dpr = !this.options.enableDpiScaling || !window ? 1 : window.devicePixelRatio,\n        width, height;\n    if (this.options.responsive) {\n      // Newer behaviour: Use the canvas's size in the layout, and set the internal\n      // resolution according to that size and the device pixel ratio (eg: high DPI)\n      width = this.canvas.offsetWidth;\n      height = this.canvas.offsetHeight;\n\n      if (width !== this.lastWidth) {\n        this.lastWidth = width;\n        this.canvas.setAttribute('width', (Math.floor(width * dpr)).toString());\n        this.canvas.getContext('2d').scale(dpr, dpr);\n      }\n      if (height !== this.lastHeight) {\n        this.lastHeight = height;\n        this.canvas.setAttribute('height', (Math.floor(height * dpr)).toString());\n        this.canvas.getContext('2d').scale(dpr, dpr);\n      }\n    } else if (dpr !== 1) {\n      // Older behaviour: use the canvas's inner dimensions and scale the element's size\n      // according to that size and the device pixel ratio (eg: high DPI)\n      width = parseInt(this.canvas.getAttribute('width'));\n      height = parseInt(this.canvas.getAttribute('height'));\n\n      if (!this.originalWidth || (Math.floor(this.originalWidth * dpr) !== width)) {\n        this.originalWidth = width;\n        this.canvas.setAttribute('width', (Math.floor(width * dpr)).toString());\n        this.canvas.style.width = width + 'px';\n        this.canvas.getContext('2d').scale(dpr, dpr);\n      }\n\n      if (!this.originalHeight || (Math.floor(this.originalHeight * dpr) !== height)) {\n        this.originalHeight = height;\n        this.canvas.setAttribute('height', (Math.floor(height * dpr)).toString());\n        this.canvas.style.height = height + 'px';\n        this.canvas.getContext('2d').scale(dpr, dpr);\n      }\n    }\n  };\n\n  /**\n   * Starts the animation of this chart.\n   */\n  SmoothieChart.prototype.start = function() {\n    if (this.frame) {\n      // We're already running, so just return\n      return;\n    }\n\n    this.canvas.addEventListener('mousemove', this.mousemove);\n    this.canvas.addEventListener('mouseout', this.mouseout);\n\n    // Renders a frame, and queues the next frame for later rendering\n    var animate = function() {\n      this.frame = SmoothieChart.AnimateCompatibility.requestAnimationFrame(function() {\n        if(this.options.nonRealtimeData){\n           var dateZero = new Date(0);\n           // find the data point with the latest timestamp\n           var maxTimeStamp = this.seriesSet.reduce(function(max, series){\n             var dataSet = series.timeSeries.data;\n             var indexToCheck = Math.round(this.options.displayDataFromPercentile * dataSet.length) - 1;\n             indexToCheck = indexToCheck >= 0 ? indexToCheck : 0;\n             indexToCheck = indexToCheck <= dataSet.length -1 ? indexToCheck : dataSet.length -1;\n             if(dataSet && dataSet.length > 0)\n             {\n              // timestamp corresponds to element 0 of the data point\n              var lastDataTimeStamp = dataSet[indexToCheck][0];\n              max = max > lastDataTimeStamp ? max : lastDataTimeStamp;\n             }\n             return max;\n          }.bind(this), dateZero);\n          // use the max timestamp as current time\n          this.render(this.canvas, maxTimeStamp > dateZero ? maxTimeStamp : null);\n        } else {\n          this.render();\n        }\n        animate();\n      }.bind(this));\n    }.bind(this);\n\n    animate();\n  };\n\n  /**\n   * Stops the animation of this chart.\n   */\n  SmoothieChart.prototype.stop = function() {\n    if (this.frame) {\n      SmoothieChart.AnimateCompatibility.cancelAnimationFrame(this.frame);\n      delete this.frame;\n      this.canvas.removeEventListener('mousemove', this.mousemove);\n      this.canvas.removeEventListener('mouseout', this.mouseout);\n    }\n  };\n\n  SmoothieChart.prototype.updateValueRange = function() {\n    // Calculate the current scale of the chart, from all time series.\n    var chartOptions = this.options,\n        chartMaxValue = Number.NaN,\n        chartMinValue = Number.NaN;\n\n    for (var d = 0; d < this.seriesSet.length; d++) {\n      // TODO(ndunn): We could calculate / track these values as they stream in.\n      var timeSeries = this.seriesSet[d].timeSeries;\n      if (timeSeries.disabled) {\n          continue;\n      }\n\n      if (!isNaN(timeSeries.maxValue)) {\n        chartMaxValue = !isNaN(chartMaxValue) ? Math.max(chartMaxValue, timeSeries.maxValue) : timeSeries.maxValue;\n      }\n\n      if (!isNaN(timeSeries.minValue)) {\n        chartMinValue = !isNaN(chartMinValue) ? Math.min(chartMinValue, timeSeries.minValue) : timeSeries.minValue;\n      }\n    }\n\n    // Scale the chartMaxValue to add padding at the top if required\n    if (chartOptions.maxValue != null) {\n      chartMaxValue = chartOptions.maxValue;\n    } else {\n      chartMaxValue *= chartOptions.maxValueScale;\n    }\n\n    // Set the minimum if we've specified one\n    if (chartOptions.minValue != null) {\n      chartMinValue = chartOptions.minValue;\n    } else {\n      chartMinValue -= Math.abs(chartMinValue * chartOptions.minValueScale - chartMinValue);\n    }\n\n    // If a custom range function is set, call it\n    if (this.options.yRangeFunction) {\n      var range = this.options.yRangeFunction({min: chartMinValue, max: chartMaxValue});\n      chartMinValue = range.min;\n      chartMaxValue = range.max;\n    }\n\n    if (!isNaN(chartMaxValue) && !isNaN(chartMinValue)) {\n      var targetValueRange = chartMaxValue - chartMinValue;\n      var valueRangeDiff = (targetValueRange - this.currentValueRange);\n      var minValueDiff = (chartMinValue - this.currentVisMinValue);\n      this.isAnimatingScale = Math.abs(valueRangeDiff) > 0.1 || Math.abs(minValueDiff) > 0.1;\n      this.currentValueRange += chartOptions.scaleSmoothing * valueRangeDiff;\n      this.currentVisMinValue += chartOptions.scaleSmoothing * minValueDiff;\n    }\n\n    this.valueRange = { min: chartMinValue, max: chartMaxValue };\n  };\n\n  SmoothieChart.prototype.render = function(canvas, time) {\n    var nowMillis = Date.now();\n\n    // Respect any frame rate limit.\n    if (this.options.limitFPS > 0 && nowMillis - this.lastRenderTimeMillis < (1000/this.options.limitFPS))\n      return;\n\n    if (!this.isAnimatingScale) {\n      // We're not animating. We can use the last render time and the scroll speed to work out whether\n      // we actually need to paint anything yet. If not, we can return immediately.\n\n      // Render at least every 1/6th of a second. The canvas may be resized, which there is\n      // no reliable way to detect.\n      var maxIdleMillis = Math.min(1000/6, this.options.millisPerPixel);\n\n      if (nowMillis - this.lastRenderTimeMillis < maxIdleMillis) {\n        return;\n      }\n    }\n\n    this.resize();\n    this.updateTooltip();\n\n    this.lastRenderTimeMillis = nowMillis;\n\n    canvas = canvas || this.canvas;\n    time = time || nowMillis - (this.delay || 0);\n\n    // Round time down to pixel granularity, so motion appears smoother.\n    time -= time % this.options.millisPerPixel;\n\n    this.lastChartTimestamp = time;\n\n    var context = canvas.getContext('2d'),\n        chartOptions = this.options,\n        dimensions = { top: 0, left: 0, width: canvas.clientWidth, height: canvas.clientHeight },\n        // Calculate the threshold time for the oldest data points.\n        oldestValidTime = time - (dimensions.width * chartOptions.millisPerPixel),\n        valueToYPixel = function(value) {\n          var offset = value - this.currentVisMinValue;\n          return this.currentValueRange === 0\n            ? dimensions.height\n            : dimensions.height - (Math.round((offset / this.currentValueRange) * dimensions.height));\n        }.bind(this),\n        timeToXPixel = function(t) {\n          if(chartOptions.scrollBackwards) {\n            return Math.round((time - t) / chartOptions.millisPerPixel);\n          }\n          return Math.round(dimensions.width - ((time - t) / chartOptions.millisPerPixel));\n        };\n\n    this.updateValueRange();\n\n    context.font = chartOptions.labels.fontSize + 'px ' + chartOptions.labels.fontFamily;\n\n    // Save the state of the canvas context, any transformations applied in this method\n    // will get removed from the stack at the end of this method when .restore() is called.\n    context.save();\n\n    // Move the origin.\n    context.translate(dimensions.left, dimensions.top);\n\n    // Create a clipped rectangle - anything we draw will be constrained to this rectangle.\n    // This prevents the occasional pixels from curves near the edges overrunning and creating\n    // screen cheese (that phrase should need no explanation).\n    context.beginPath();\n    context.rect(0, 0, dimensions.width, dimensions.height);\n    context.clip();\n\n    // Clear the working area.\n    context.save();\n    context.fillStyle = chartOptions.grid.fillStyle;\n    context.clearRect(0, 0, dimensions.width, dimensions.height);\n    context.fillRect(0, 0, dimensions.width, dimensions.height);\n    context.restore();\n\n    // Grid lines...\n    context.save();\n    context.lineWidth = chartOptions.grid.lineWidth;\n    context.strokeStyle = chartOptions.grid.strokeStyle;\n    // Vertical (time) dividers.\n    if (chartOptions.grid.millisPerLine > 0) {\n      context.beginPath();\n      for (var t = time - (time % chartOptions.grid.millisPerLine);\n           t >= oldestValidTime;\n           t -= chartOptions.grid.millisPerLine) {\n        var gx = timeToXPixel(t);\n        if (chartOptions.grid.sharpLines) {\n          gx -= 0.5;\n        }\n        context.moveTo(gx, 0);\n        context.lineTo(gx, dimensions.height);\n      }\n      context.stroke();\n      context.closePath();\n    }\n\n    // Horizontal (value) dividers.\n    for (var v = 1; v < chartOptions.grid.verticalSections; v++) {\n      var gy = Math.round(v * dimensions.height / chartOptions.grid.verticalSections);\n      if (chartOptions.grid.sharpLines) {\n        gy -= 0.5;\n      }\n      context.beginPath();\n      context.moveTo(0, gy);\n      context.lineTo(dimensions.width, gy);\n      context.stroke();\n      context.closePath();\n    }\n    // Bounding rectangle.\n    if (chartOptions.grid.borderVisible) {\n      context.beginPath();\n      context.strokeRect(0, 0, dimensions.width, dimensions.height);\n      context.closePath();\n    }\n    context.restore();\n\n    // Draw any horizontal lines...\n    if (chartOptions.horizontalLines && chartOptions.horizontalLines.length) {\n      for (var hl = 0; hl < chartOptions.horizontalLines.length; hl++) {\n        var line = chartOptions.horizontalLines[hl],\n            hly = Math.round(valueToYPixel(line.value)) - 0.5;\n        context.strokeStyle = line.color || '#ffffff';\n        context.lineWidth = line.lineWidth || 1;\n        context.beginPath();\n        context.moveTo(0, hly);\n        context.lineTo(dimensions.width, hly);\n        context.stroke();\n        context.closePath();\n      }\n    }\n\n    // For each data set...\n    for (var d = 0; d < this.seriesSet.length; d++) {\n      context.save();\n      var timeSeries = this.seriesSet[d].timeSeries;\n      if (timeSeries.disabled) {\n          continue;\n      }\n\n      var dataSet = timeSeries.data,\n          seriesOptions = this.seriesSet[d].options;\n\n      // Delete old data that's moved off the left of the chart.\n      timeSeries.dropOldData(oldestValidTime, chartOptions.maxDataSetLength);\n\n      // Set style for this dataSet.\n      context.lineWidth = seriesOptions.lineWidth;\n      context.strokeStyle = seriesOptions.strokeStyle;\n      // Draw the line...\n      context.beginPath();\n      // Retain lastX, lastY for calculating the control points of bezier curves.\n      var firstX = 0, lastX = 0, lastY = 0;\n      for (var i = 0; i < dataSet.length && dataSet.length !== 1; i++) {\n        var x = timeToXPixel(dataSet[i][0]),\n            y = valueToYPixel(dataSet[i][1]);\n\n        if (i === 0) {\n          firstX = x;\n          context.moveTo(x, y);\n        } else {\n          switch (chartOptions.interpolation) {\n            case \"linear\":\n            case \"line\": {\n              context.lineTo(x,y);\n              break;\n            }\n            case \"bezier\":\n            default: {\n              // Great explanation of Bezier curves: http://en.wikipedia.org/wiki/Bezier_curve#Quadratic_curves\n              //\n              // Assuming A was the last point in the line plotted and B is the new point,\n              // we draw a curve with control points P and Q as below.\n              //\n              // A---P\n              //     |\n              //     |\n              //     |\n              //     Q---B\n              //\n              // Importantly, A and P are at the same y coordinate, as are B and Q. This is\n              // so adjacent curves appear to flow as one.\n              //\n              context.bezierCurveTo( // startPoint (A) is implicit from last iteration of loop\n                Math.round((lastX + x) / 2), lastY, // controlPoint1 (P)\n                Math.round((lastX + x)) / 2, y, // controlPoint2 (Q)\n                x, y); // endPoint (B)\n              break;\n            }\n            case \"step\": {\n              context.lineTo(x,lastY);\n              context.lineTo(x,y);\n              break;\n            }\n          }\n        }\n\n        lastX = x; lastY = y;\n      }\n\n      if (dataSet.length > 1) {\n        if (seriesOptions.fillStyle) {\n          // Close up the fill region.\n          context.lineTo(dimensions.width + seriesOptions.lineWidth + 1, lastY);\n          context.lineTo(dimensions.width + seriesOptions.lineWidth + 1, dimensions.height + seriesOptions.lineWidth + 1);\n          context.lineTo(firstX, dimensions.height + seriesOptions.lineWidth);\n          context.fillStyle = seriesOptions.fillStyle;\n          context.fill();\n        }\n\n        if (seriesOptions.strokeStyle && seriesOptions.strokeStyle !== 'none') {\n          context.stroke();\n        }\n        context.closePath();\n      }\n      context.restore();\n    }\n\n    if (chartOptions.tooltip && this.mouseX >= 0) {\n      // Draw vertical bar to show tooltip position\n      context.lineWidth = chartOptions.tooltipLine.lineWidth;\n      context.strokeStyle = chartOptions.tooltipLine.strokeStyle;\n      context.beginPath();\n      context.moveTo(this.mouseX, 0);\n      context.lineTo(this.mouseX, dimensions.height);\n      context.closePath();\n      context.stroke();\n      this.updateTooltip();\n    }\n\n    // Draw the axis values on the chart.\n    if (!chartOptions.labels.disabled && !isNaN(this.valueRange.min) && !isNaN(this.valueRange.max)) {\n      var maxValueString = chartOptions.yMaxFormatter(this.valueRange.max, chartOptions.labels.precision),\n          minValueString = chartOptions.yMinFormatter(this.valueRange.min, chartOptions.labels.precision),\n          maxLabelPos = chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(maxValueString).width - 2,\n          minLabelPos = chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(minValueString).width - 2;\n      context.fillStyle = chartOptions.labels.fillStyle;\n      context.fillText(maxValueString, maxLabelPos, chartOptions.labels.fontSize);\n      context.fillText(minValueString, minLabelPos, dimensions.height - 2);\n    }\n\n    // Display intermediate y axis labels along y-axis to the left of the chart\n    if ( chartOptions.labels.showIntermediateLabels\n          && !isNaN(this.valueRange.min) && !isNaN(this.valueRange.max)\n          && chartOptions.grid.verticalSections > 0) {\n      // show a label above every vertical section divider\n      var step = (this.valueRange.max - this.valueRange.min) / chartOptions.grid.verticalSections;\n      var stepPixels = dimensions.height / chartOptions.grid.verticalSections;\n      for (var v = 1; v < chartOptions.grid.verticalSections; v++) {\n        var gy = dimensions.height - Math.round(v * stepPixels);\n        if (chartOptions.grid.sharpLines) {\n          gy -= 0.5;\n        }\n        var yValue = chartOptions.yIntermediateFormatter(this.valueRange.min + (v * step), chartOptions.labels.precision);\n        //left of right axis?\n        intermediateLabelPos =\n          chartOptions.labels.intermediateLabelSameAxis\n          ? (chartOptions.scrollBackwards ? 0 : dimensions.width - context.measureText(yValue).width - 2)\n          : (chartOptions.scrollBackwards ? dimensions.width - context.measureText(yValue).width - 2 : 0);\n\n        context.fillText(yValue, intermediateLabelPos, gy - chartOptions.grid.lineWidth);\n      }\n    }\n\n    // Display timestamps along x-axis at the bottom of the chart.\n    if (chartOptions.timestampFormatter && chartOptions.grid.millisPerLine > 0) {\n      var textUntilX = chartOptions.scrollBackwards\n        ? context.measureText(minValueString).width\n        : dimensions.width - context.measureText(minValueString).width + 4;\n      for (var t = time - (time % chartOptions.grid.millisPerLine);\n           t >= oldestValidTime;\n           t -= chartOptions.grid.millisPerLine) {\n        var gx = timeToXPixel(t);\n        // Only draw the timestamp if it won't overlap with the previously drawn one.\n        if ((!chartOptions.scrollBackwards && gx < textUntilX) || (chartOptions.scrollBackwards && gx > textUntilX))  {\n          // Formats the timestamp based on user specified formatting function\n          // SmoothieChart.timeFormatter function above is one such formatting option\n          var tx = new Date(t),\n            ts = chartOptions.timestampFormatter(tx),\n            tsWidth = context.measureText(ts).width;\n\n          textUntilX = chartOptions.scrollBackwards\n            ? gx + tsWidth + 2\n            : gx - tsWidth - 2;\n\n          context.fillStyle = chartOptions.labels.fillStyle;\n          if(chartOptions.scrollBackwards) {\n            context.fillText(ts, gx, dimensions.height - 2);\n          } else {\n            context.fillText(ts, gx - tsWidth, dimensions.height - 2);\n          }\n        }\n      }\n    }\n\n    context.restore(); // See .save() above.\n  };\n\n  // Sample timestamp formatting function\n  SmoothieChart.timeFormatter = function(date) {\n    function pad2(number) { return (number < 10 ? '0' : '') + number }\n    return pad2(date.getHours()) + ':' + pad2(date.getMinutes()) + ':' + pad2(date.getSeconds());\n  };\n\n  exports.TimeSeries = TimeSeries;\n  exports.SmoothieChart = SmoothieChart;\n\n})( false ? undefined : exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vbm9kZV9tb2R1bGVzL3Ntb290aGllL3Ntb290aGllLmpzPzI1ODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EscUNBQXFDLDZCQUE2Qjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEsR0FBRyxTQUFTLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsUUFBUTtBQUNSLGdEQUFnRDtBQUNoRDtBQUNBLFFBQVE7QUFDUixrRUFBa0U7QUFDbEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsMEhBQTBILFdBQVc7QUFDckk7QUFDQSx1REFBdUQsMkNBQTJDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQywyREFBMkQ7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrRkFBa0Y7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsdUNBQXVDO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsMEVBQTBFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0NBQXdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsRUFBRSxNQUE4QixHQUFHLFNBQUkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc21vb3RoaWUvc21vb3RoaWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNSVQgTGljZW5zZTpcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMywgSm9lIFdhbG5lc1xuLy8gICAgICAgICAgICAgICAyMDEzLTIwMTgsIERyZXcgTm9ha2VzXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBTbW9vdGhpZSBDaGFydHMgLSBodHRwOi8vc21vb3RoaWVjaGFydHMub3JnL1xuICogKGMpIDIwMTAtMjAxMywgSm9lIFdhbG5lc1xuICogICAgIDIwMTMtMjAxOCwgRHJldyBOb2FrZXNcbiAqXG4gKiB2MS4wOiBNYWluIGNoYXJ0aW5nIGxpYnJhcnksIGJ5IEpvZSBXYWxuZXNcbiAqIHYxLjE6IEF1dG8gc2NhbGluZyBvZiBheGlzLCBieSBOZWlsIER1bm5cbiAqIHYxLjI6IGZwcyAoZnJhbWVzIHBlciBzZWNvbmQpIG9wdGlvbiwgYnkgTWF0aGlhcyBQZXR0ZXJzb25cbiAqIHYxLjM6IEZpeCBmb3IgZGl2aWRlIGJ5IHplcm8sIGJ5IFBhdWwgTmlraXRvY2hraW5cbiAqIHYxLjQ6IFNldCBtaW5pbXVtLCB0b3Atc2NhbGUgcGFkZGluZywgcmVtb3ZlIHRpbWVzZXJpZXMsIGFkZCBvcHRpb25hbCB0aW1lciB0byByZXNldCBib3VuZHMsIGJ5IEtlbGxleSBSZXlub2xkc1xuICogdjEuNTogU2V0IGRlZmF1bHQgZnJhbWVzIHBlciBzZWNvbmQgdG8gNTAuLi4gc21vb3RoZXIuXG4gKiAgICAgICAuc3RhcnQoKSwgLnN0b3AoKSBtZXRob2RzIGZvciBjb25zZXJ2aW5nIENQVSwgYnkgRG1pdHJ5IFZ5YWxcbiAqICAgICAgIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiA9ICdiZXppZXInIG9yICdsaW5lJywgYnkgRG1pdHJ5IFZ5YWxcbiAqICAgICAgIG9wdGlvbnMubWF4VmFsdWUgdG8gZml4IHNjYWxlLCBieSBEbWl0cnkgVnlhbFxuICogdjEuNjogbWluVmFsdWUvbWF4VmFsdWUgd2lsbCBhbHdheXMgZ2V0IGNvbnZlcnRlZCB0byBmbG9hdHMsIGJ5IFByemVtZWsgTWF0eWxsYVxuICogdjEuNzogb3B0aW9ucy5ncmlkLmZpbGxTdHlsZSBtYXkgYmUgYSB0cmFuc3BhcmVudCBjb2xvciwgYnkgRG1pdHJ5IEEuIFNoYXNoa2luXG4gKiAgICAgICBTbW9vdGggcmVzY2FsaW5nLCBieSBLb3N0YXMgTWljaGFsb3BvdWxvc1xuICogdjEuODogU2V0IG1heCBsZW5ndGggdG8gY3VzdG9taXplIG51bWJlciBvZiBsaXZlIHBvaW50cyBpbiB0aGUgZGF0YXNldCB3aXRoIG9wdGlvbnMubWF4RGF0YVNldExlbmd0aCwgYnkgS3Jpc2huYSBOYXJuaVxuICogdjEuOTogRGlzcGxheSB0aW1lc3RhbXBzIGFsb25nIHRoZSBib3R0b20sIGJ5IE5pY2sgYW5kIFN0ZXYtaW9cbiAqICAgICAgIChodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLz9mcm9tZ3JvdXBzIyF0b3BpYy9zbW9vdGhpZS1jaGFydHMvLVl3c2U4RkNwS0klNUIxLTI1JTVEKVxuICogICAgICAgUmVmYWN0b3JlZCBieSBLcmlzaG5hIE5hcm5pLCB0byBzdXBwb3J0IHRpbWVzdGFtcCBmb3JtYXR0aW5nIGZ1bmN0aW9uXG4gKiB2MS4xMDogU3dpdGNoIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgcmVtb3ZlZCB0aGUgbm93IG9ic29sZXRlZCBvcHRpb25zLmZwcywgYnkgR2VyZ2VseSBJbXJlaFxuICogdjEuMTE6IG9wdGlvbnMuZ3JpZC5zaGFycExpbmVzIG9wdGlvbiBhZGRlZCwgYnkgQGRyZXdub2FrZXNcbiAqICAgICAgICBBZGRyZXNzZWQgd2FybmluZyBzZWVuIGluIEZpcmVmb3ggd2hlbiBzZXJpZXNPcHRpb24uZmlsbFN0eWxlIHVuZGVmaW5lZCwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjEyOiBTdXBwb3J0IGZvciBob3Jpem9udGFsTGluZXMgYWRkZWQsIGJ5IEBkcmV3bm9ha2VzXG4gKiAgICAgICAgU3VwcG9ydCBmb3IgeVJhbmdlRnVuY3Rpb24gY2FsbGJhY2sgYWRkZWQsIGJ5IEBkcmV3bm9ha2VzXG4gKiB2MS4xMzogRml4ZWQgdHlwbyAoIzMyKSwgYnkgQGFsbmlraXRpY2hcbiAqIHYxLjE0OiBUaW1lciBjbGVhcmVkIHdoZW4gbGFzdCBUaW1lU2VyaWVzIHJlbW92ZWQgKCMyMyksIGJ5IEBkYXZpZGdhbGVhbm9cbiAqICAgICAgICBGaXhlZCBkaWFnb25hbCBsaW5lIG9uIGNoYXJ0IGF0IHN0YXJ0L2VuZCBvZiBkYXRhIHN0cmVhbSwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjE1OiBTdXBwb3J0IGZvciBucG0gcGFja2FnZSAoIzE4KSwgYnkgQGRvbWluaWN0YXJyXG4gKiAgICAgICAgRml4ZWQgYnJva2VuIHJlbW92ZVRpbWVTZXJpZXMgZnVuY3Rpb24gKCMyNCkgYnkgQGRhdmlkZ2FsZWFub1xuICogICAgICAgIE1pbm9yIHBlcmZvcm1hbmNlIGFuZCB0aWR5aW5nLCBieSBAZHJld25vYWtlc1xuICogdjEuMTY6IEJ1ZyBmaXggaW50cm9kdWNlZCBpbiB2MS4xNCByZWxhdGluZyB0byB0aW1lciBjcmVhdGlvbi9jbGVhcmFuY2UgKCMyMyksIGJ5IEBkcmV3bm9ha2VzXG4gKiAgICAgICAgVGltZVNlcmllcy5hcHBlbmQgbm93IGRlYWxzIHdpdGggb3V0LW9mLW9yZGVyIHRpbWVzdGFtcHMsIGFuZCBjYW4gbWVyZ2UgZHVwbGljYXRlcywgYnkgQHphY3dpdHRlICgjMTIpXG4gKiAgICAgICAgRG9jdW1lbnRhdGlvbiBhbmQgc29tZSBsb2NhbCB2YXJpYWJsZSByZW5hbWluZyBmb3IgY2xhcml0eSwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjE3OiBBbGxvdyBjb250cm9sIG92ZXIgZm9udCBzaXplICgjMTApLCBieSBAZHJld25vYWtlc1xuICogICAgICAgIFRpbWVzdGFtcCB0ZXh0IHdvbid0IG92ZXJsYXAsIGJ5IEBkcmV3bm9ha2VzXG4gKiB2MS4xODogQWxsb3cgY29udHJvbCBvZiBtYXgvbWluIGxhYmVsIHByZWNpc2lvbiwgYnkgQGRyZXdub2FrZXNcbiAqICAgICAgICBBZGRlZCAnYm9yZGVyVmlzaWJsZScgY2hhcnQgb3B0aW9uLCBieSBAZHJld25vYWtlc1xuICogICAgICAgIEFsbG93IGRyYXdpbmcgc2VyaWVzIHdpdGggZmlsbCBidXQgbm8gc3Ryb2tlIChsaW5lKSwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjE5OiBBdm9pZCB1bm5lY2Vzc2FyeSByZXBhaW50cywgYW5kIGZpeGVkIGZsaWNrZXIgaW4gb2xkIGJyb3dzZXJzIGhhdmluZyBtdWx0aXBsZSBjaGFydHMgaW4gZG9jdW1lbnQgKCM0MCksIGJ5IEBhc2JhaVxuICogdjEuMjA6IEFkZCBTbW9vdGhpZUNoYXJ0LmdldFRpbWVTZXJpZXNPcHRpb25zIGFuZCBTbW9vdGhpZUNoYXJ0LmJyaW5nVG9Gcm9udCBmdW5jdGlvbnMsIGJ5IEBkcmV3bm9ha2VzXG4gKiB2MS4yMTogQWRkICdzdGVwJyBpbnRlcnBvbGF0aW9uIG1vZGUsIGJ5IEBkcmV3bm9ha2VzXG4gKiB2MS4yMjogQWRkIHN1cHBvcnQgZm9yIGRpZmZlcmVudCBwaXhlbCByYXRpb3MuIEFsc28gYWRkIG9wdGlvbmFsIHkgbGltaXQgZm9ybWF0dGVycywgYnkgQGNvcGFjZXRpY1xuICogdjEuMjM6IEZpeCBidWcgaW50cm9kdWNlZCBpbiB2MS4yMiAoIzQ0KSwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjI0OiBGaXggYnVnIGludHJvZHVjZWQgaW4gdjEuMjMsIHJlLWFkZGluZyBwYXJzZUZsb2F0IHRvIHktYXhpcyBmb3JtYXR0ZXIgZGVmYXVsdHMsIGJ5IEBzaWdneV9zZlxuICogdjEuMjU6IEZpeCBidWcgc2VlbiB3aGVuIGFkZGluZyBhIGRhdGEgcG9pbnQgdG8gVGltZVNlcmllcyB3aGljaCBpcyBvbGRlciB0aGFuIHRoZSBjdXJyZW50IGRhdGEsIGJ5IEBOa2luZzkyXG4gKiAgICAgICAgRHJhdyB0aW1lIGxhYmVscyBvbiB0b3Agb2Ygc2VyaWVzLCBieSBAY29tb2xvc2FiaWFcbiAqICAgICAgICBBZGQgVGltZVNlcmllcy5jbGVhciBmdW5jdGlvbiwgYnkgQGRyZXdub2FrZXNcbiAqIHYxLjI2OiBBZGQgc3VwcG9ydCBmb3IgcmVzaXppbmcgb24gaGlnaCBkZXZpY2UgcGl4ZWwgcmF0aW8gc2NyZWVucywgYnkgQGNvcGFjZXRpY1xuICogdjEuMjc6IEZpeCBidWcgaW50cm9kdWNlZCBpbiB2MS4yNiBmb3Igbm9uIHdob2xlIG51bWJlciBkZXZpY2VQaXhlbFJhdGlvIHZhbHVlcywgYnkgQHptYnVzaFxuICogdjEuMjg6IEFkZCAnbWluVmFsdWVTY2FsZScgb3B0aW9uLCBieSBAbWVnYXdhY1xuICogICAgICAgIEZpeCAnbGFiZWxQb3MnIGZvciBkaWZmZXJlbnQgc2l6ZSBvZiAnbWluVmFsdWVTdHJpbmcnICdtYXhWYWx1ZVN0cmluZycsIGJ5IEBoZW5yeW5cbiAqIHYxLjI5OiBTdXBwb3J0IHJlc3BvbnNpdmUgc2l6aW5nLCBieSBAZHJld25vYWtlc1xuICogdjEuMjkuMTogSW5jbHVkZSB0eXBlcyBpbiBwYWNrYWdlLCBhbmQgbWFrZSBwcm9wZXJ0eSBvcHRpb25hbCwgYnkgQFRyZW50SG91bGlzdG9uXG4gKiB2MS4zMDogRml4IGludmVydGVkIGxvZ2ljIGluIGRldmljZVBpeGVsUmF0aW8gc3VwcG9ydCwgYnkgQHNjYW5saW1lXG4gKiB2MS4zMTogU3VwcG9ydCB0b29sdGlwcywgYnkgQFNseTEwMjQgYW5kIEBkcmV3bm9ha2VzXG4gKiB2MS4zMjogU3VwcG9ydCBmcmFtZSByYXRlIGxpbWl0LCBieSBAZHB1eW9zYVxuICogdjEuMzM6IFVzZSBEYXRlIHN0YXRpYyBtZXRob2QgaW5zdGVhZCBvZiBpbnN0YW5jZSwgYnkgQG5ubm9lbFxuICogICAgICAgIEZpeCBidWcgd2l0aCB0b29sdGlwcyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBvbiBhIHBhZ2UsIGJ5IEBqcG1iaXo3MFxuICogdjEuMzQ6IEFkZCBkaXNhYmxlZCBvcHRpb24gdG8gVGltZVNlcmllcywgYnkgQFRlY2hHdWFyZCAoIzkxKVxuICogICAgICAgIEFkZCBub25SZWFsdGltZURhdGEgb3B0aW9uLCBieSBAYW5uYXpoZWx0ICgjOTIsICM5MylcbiAqICAgICAgICBBZGQgc2hvd0ludGVybWVkaWF0ZUxhYmVscyBvcHRpb24sIGJ5IEBhbm5hemhlbHQgKCM5NClcbiAqICAgICAgICBBZGQgZGlzcGxheURhdGFGcm9tUGVyY2VudGlsZSBvcHRpb24sIGJ5IEBhbm5hemhlbHQgKCM5NSlcbiAqICAgICAgICBGaXggYnVnIHdoZW4gaGlkaW5nIHRvb2x0aXAgZWxlbWVudCwgYnkgQHJhbHBod2V0emVsICgjOTYpXG4gKiAgICAgICAgU3VwcG9ydCBpbnRlcm1lZGlhdGUgeS1heGlzIGxhYmVscywgYnkgQGJlaWtlbGFuZCAoIzk5KVxuICogdjEuMzU6IEZpeCBpc3N1ZSB3aXRoIHJlc3BvbnNpdmUgbW9kZSBhdCBoaWdoIERQSSwgYnkgQGRyZXdub2FrZXMgKCMxMDEpXG4gKi9cblxuOyhmdW5jdGlvbihleHBvcnRzKSB7XG5cbiAgLy8gRGF0ZS5ub3cgcG9seWZpbGxcbiAgRGF0ZS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuXG4gIHZhciBVdGlsID0ge1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF0gfHwge307XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1tpXSlcbiAgICAgICAge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKGFyZ3VtZW50c1tpXVtrZXldKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXVtrZXldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1ba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXVtrZXldID0gVXRpbC5leHRlbmQoYXJndW1lbnRzWzBdW2tleV0sIGFyZ3VtZW50c1tpXVtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXJndW1lbnRzWzBdW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgfSxcbiAgICBiaW5hcnlTZWFyY2g6IGZ1bmN0aW9uKGRhdGEsIHZhbHVlKSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gZGF0YS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7XG4gICAgICAgIGlmICh2YWx1ZSA8IGRhdGFbbWlkXVswXSlcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb3c7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlcyBhIG5ldyA8Y29kZT5UaW1lU2VyaWVzPC9jb2RlPiB3aXRoIG9wdGlvbmFsIGRhdGEgb3B0aW9ucy5cbiAgICpcbiAgICogT3B0aW9ucyBhcmUgb2YgdGhlIGZvcm0gKGRlZmF1bHRzIHNob3duKTpcbiAgICpcbiAgICogPHByZT5cbiAgICoge1xuICAgKiAgIHJlc2V0Qm91bmRzOiB0cnVlLCAgICAgICAgLy8gZW5hYmxlcy9kaXNhYmxlcyBhdXRvbWF0aWMgc2NhbGluZyBvZiB0aGUgeS1heGlzXG4gICAqICAgcmVzZXRCb3VuZHNJbnRlcnZhbDogMzAwMCAvLyB0aGUgcGVyaW9kIGJldHdlZW4gc2NhbGluZyBjYWxjdWxhdGlvbnMsIGluIG1pbGxpc1xuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBQcmVzZW50YXRpb24gb3B0aW9ucyBmb3IgVGltZVNlcmllcyBhcmUgc3BlY2lmaWVkIGFzIGFuIGFyZ3VtZW50IHRvIDxjb2RlPlNtb290aGllQ2hhcnQuYWRkVGltZVNlcmllczwvY29kZT4uXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gVGltZVNlcmllcyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gVXRpbC5leHRlbmQoe30sIFRpbWVTZXJpZXMuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gIH1cblxuICBUaW1lU2VyaWVzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIHJlc2V0Qm91bmRzSW50ZXJ2YWw6IDMwMDAsXG4gICAgcmVzZXRCb3VuZHM6IHRydWVcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBkYXRhIGFuZCBzdGF0ZSBmcm9tIHRoaXMgVGltZVNlcmllcyBvYmplY3QuXG4gICAqL1xuICBUaW1lU2VyaWVzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMubWF4VmFsdWUgPSBOdW1iZXIuTmFOOyAvLyBUaGUgbWF4aW11bSB2YWx1ZSBldmVyIHNlZW4gaW4gdGhpcyBUaW1lU2VyaWVzLlxuICAgIHRoaXMubWluVmFsdWUgPSBOdW1iZXIuTmFOOyAvLyBUaGUgbWluaW11bSB2YWx1ZSBldmVyIHNlZW4gaW4gdGhpcyBUaW1lU2VyaWVzLlxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSB0aGUgbWluL21heCB2YWx1ZXMgZm9yIHRoaXMgPGNvZGU+VGltZVNlcmllczwvY29kZT4gb2JqZWN0LlxuICAgKlxuICAgKiBUaGlzIGNhdXNlcyB0aGUgZ3JhcGggdG8gc2NhbGUgaXRzZWxmIGluIHRoZSB5LWF4aXMuXG4gICAqL1xuICBUaW1lU2VyaWVzLnByb3RvdHlwZS5yZXNldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyBXYWxrIHRocm91Z2ggYWxsIGRhdGEgcG9pbnRzLCBmaW5kaW5nIHRoZSBtaW4vbWF4IHZhbHVlXG4gICAgICB0aGlzLm1heFZhbHVlID0gdGhpcy5kYXRhWzBdWzFdO1xuICAgICAgdGhpcy5taW5WYWx1ZSA9IHRoaXMuZGF0YVswXVsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZGF0YVtpXVsxXTtcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5tYXhWYWx1ZSkge1xuICAgICAgICAgIHRoaXMubWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLm1pblZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5taW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRhdGEgZXhpc3RzLCBzbyBzZXQgbWluL21heCB0byBOYU5cbiAgICAgIHRoaXMubWF4VmFsdWUgPSBOdW1iZXIuTmFOO1xuICAgICAgdGhpcy5taW5WYWx1ZSA9IE51bWJlci5OYU47XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGRhdGEgcG9pbnQgdG8gdGhlIDxjb2RlPlRpbWVTZXJpZXM8L2NvZGU+LCBwcmVzZXJ2aW5nIGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgdGhlIHBvc2l0aW9uLCBpbiB0aW1lLCBvZiB0aGlzIGRhdGEgcG9pbnRcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGlzIGRhdGEgcG9pbnRcbiAgICogQHBhcmFtIHN1bVJlcGVhdGVkVGltZVN0YW1wVmFsdWVzIGlmIDxjb2RlPnRpbWVzdGFtcDwvY29kZT4gaGFzIGFuIGV4YWN0IG1hdGNoIGluIHRoZSBzZXJpZXMsIHRoaXMgZmxhZyBjb250cm9sc1xuICAgKiB3aGV0aGVyIGl0IGlzIHJlcGxhY2VkLCBvciB0aGUgdmFsdWVzIHN1bW1lZCAoZGVmYXVsdHMgdG8gZmFsc2UuKVxuICAgKi9cbiAgVGltZVNlcmllcy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24odGltZXN0YW1wLCB2YWx1ZSwgc3VtUmVwZWF0ZWRUaW1lU3RhbXBWYWx1ZXMpIHtcbiAgICAvLyBSZXdpbmQgdW50aWwgd2UgaGl0IGFuIG9sZGVyIHRpbWVzdGFtcFxuICAgIHZhciBpID0gdGhpcy5kYXRhLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiB0aGlzLmRhdGFbaV1bMF0gPiB0aW1lc3RhbXApIHtcbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIC8vIFRoaXMgbmV3IGl0ZW0gaXMgdGhlIG9sZGVzdCBkYXRhXG4gICAgICB0aGlzLmRhdGEuc3BsaWNlKDAsIDAsIFt0aW1lc3RhbXAsIHZhbHVlXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEubGVuZ3RoID4gMCAmJiB0aGlzLmRhdGFbaV1bMF0gPT09IHRpbWVzdGFtcCkge1xuICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHZhbHVlcyBpbiB0aGUgYXJyYXlcbiAgICAgIGlmIChzdW1SZXBlYXRlZFRpbWVTdGFtcFZhbHVlcykge1xuICAgICAgICAvLyBTdW0gdGhpcyB2YWx1ZSBpbnRvIHRoZSBleGlzdGluZyAnYnVja2V0J1xuICAgICAgICB0aGlzLmRhdGFbaV1bMV0gKz0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gdGhpcy5kYXRhW2ldWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgdGhpcy5kYXRhW2ldWzFdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpIDwgdGhpcy5kYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIFNwbGljZSBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIHRvIGtlZXAgdGltZXN0YW1wcyBpbiBvcmRlclxuICAgICAgdGhpcy5kYXRhLnNwbGljZShpICsgMSwgMCwgW3RpbWVzdGFtcCwgdmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAgICB0aGlzLmRhdGEucHVzaChbdGltZXN0YW1wLCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIHRoaXMubWF4VmFsdWUgPSBpc05hTih0aGlzLm1heFZhbHVlKSA/IHZhbHVlIDogTWF0aC5tYXgodGhpcy5tYXhWYWx1ZSwgdmFsdWUpO1xuICAgIHRoaXMubWluVmFsdWUgPSBpc05hTih0aGlzLm1pblZhbHVlKSA/IHZhbHVlIDogTWF0aC5taW4odGhpcy5taW5WYWx1ZSwgdmFsdWUpO1xuICB9O1xuXG4gIFRpbWVTZXJpZXMucHJvdG90eXBlLmRyb3BPbGREYXRhID0gZnVuY3Rpb24ob2xkZXN0VmFsaWRUaW1lLCBtYXhEYXRhU2V0TGVuZ3RoKSB7XG4gICAgLy8gV2UgbXVzdCBhbHdheXMga2VlcCBvbmUgZXhwaXJlZCBkYXRhIHBvaW50IGFzIHdlIG5lZWQgdGhpcyB0byBkcmF3IHRoZVxuICAgIC8vIGxpbmUgdGhhdCBjb21lcyBpbnRvIHRoZSBjaGFydCBmcm9tIHRoZSBsZWZ0LCBidXQgYW55IHBvaW50cyBwcmlvciB0byB0aGF0IGNhbiBiZSByZW1vdmVkLlxuICAgIHZhciByZW1vdmVDb3VudCA9IDA7XG4gICAgd2hpbGUgKHRoaXMuZGF0YS5sZW5ndGggLSByZW1vdmVDb3VudCA+PSBtYXhEYXRhU2V0TGVuZ3RoICYmIHRoaXMuZGF0YVtyZW1vdmVDb3VudCArIDFdWzBdIDwgb2xkZXN0VmFsaWRUaW1lKSB7XG4gICAgICByZW1vdmVDb3VudCsrO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlQ291bnQgIT09IDApIHtcbiAgICAgIHRoaXMuZGF0YS5zcGxpY2UoMCwgcmVtb3ZlQ291bnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGlzZXMgYSBuZXcgPGNvZGU+U21vb3RoaWVDaGFydDwvY29kZT4uXG4gICAqXG4gICAqIE9wdGlvbnMgYXJlIG9wdGlvbmFsLCBhbmQgc2hvdWxkIGJlIG9mIHRoZSBmb3JtIGJlbG93LiBKdXN0IHNwZWNpZnkgdGhlIHZhbHVlcyB5b3VcbiAgICogbmVlZCBhbmQgdGhlIHJlc3Qgd2lsbCBiZSBnaXZlbiBzZW5zaWJsZSBkZWZhdWx0cyBhcyBzaG93bjpcbiAgICpcbiAgICogPHByZT5cbiAgICoge1xuICAgKiAgIG1pblZhbHVlOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZnkgdG8gY2xhbXAgdGhlIGxvd2VyIHktYXhpcyB0byBhIGdpdmVuIHZhbHVlXG4gICAqICAgbWF4VmFsdWU6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmeSB0byBjbGFtcCB0aGUgdXBwZXIgeS1heGlzIHRvIGEgZ2l2ZW4gdmFsdWVcbiAgICogICBtYXhWYWx1ZVNjYWxlOiAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgcHJvcG9ydGlvbmFsIHBhZGRpbmcgdG8gYmUgYWRkZWQgYWJvdmUgdGhlIGNoYXJ0LiBmb3IgMTAlIHBhZGRpbmcsIHNwZWNpZnkgMS4xLlxuICAgKiAgIG1pblZhbHVlU2NhbGU6IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93cyBwcm9wb3J0aW9uYWwgcGFkZGluZyB0byBiZSBhZGRlZCBiZWxvdyB0aGUgY2hhcnQuIGZvciAxMCUgcGFkZGluZywgc3BlY2lmeSAxLjEuXG4gICAqICAgeVJhbmdlRnVuY3Rpb246IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24oe21pbjogLCBtYXg6IH0pIHsgcmV0dXJuIHttaW46ICwgbWF4OiB9OyB9XG4gICAqICAgc2NhbGVTbW9vdGhpbmc6IDAuMTI1LCAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbHMgdGhlIHJhdGUgYXQgd2hpY2ggeS12YWx1ZSB6b29tIGFuaW1hdGlvbiBvY2N1cnNcbiAgICogICBtaWxsaXNQZXJQaXhlbDogMjAsICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRzIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgY2hhcnQgcGFucyBieVxuICAgKiAgIGVuYWJsZURwaVNjYWxpbmc6IHRydWUsICAgICAgICAgICAgICAgICAgIC8vIHN1cHBvcnQgcmVuZGVyaW5nIGF0IGRpZmZlcmVudCBEUEkgZGVwZW5kaW5nIG9uIHRoZSBkZXZpY2VcbiAgICogICB5TWluRm9ybWF0dGVyOiBmdW5jdGlvbihtaW4sIHByZWNpc2lvbikgeyAvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgdGhlIG1pbiB5IHZhbHVlIGxhYmVsXG4gICAqICAgICByZXR1cm4gcGFyc2VGbG9hdChtaW4pLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICogICB9LFxuICAgKiAgIHlNYXhGb3JtYXR0ZXI6IGZ1bmN0aW9uKG1heCwgcHJlY2lzaW9uKSB7IC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyB0aGUgbWF4IHkgdmFsdWUgbGFiZWxcbiAgICogICAgIHJldHVybiBwYXJzZUZsb2F0KG1heCkudG9GaXhlZChwcmVjaXNpb24pO1xuICAgKiAgIH0sXG4gICAqICAgeUludGVybWVkaWF0ZUZvcm1hdHRlcjogZnVuY3Rpb24oaW50ZXJtZWRpYXRlLCBwcmVjaXNpb24pIHsgLy8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIHRoZSBpbnRlcm1lZGlhdGUgeSB2YWx1ZSBsYWJlbHNcbiAgICogICAgIHJldHVybiBwYXJzZUZsb2F0KGludGVybWVkaWF0ZSkudG9GaXhlZChwcmVjaXNpb24pO1xuICAgKiAgIH0sXG4gICAqICAgbWF4RGF0YVNldExlbmd0aDogMixcbiAgICogICBpbnRlcnBvbGF0aW9uOiAnYmV6aWVyJyAgICAgICAgICAgICAgICAgICAvLyBvbmUgb2YgJ2JlemllcicsICdsaW5lYXInLCBvciAnc3RlcCdcbiAgICogICB0aW1lc3RhbXBGb3JtYXR0ZXI6IG51bGwsICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBmdW5jdGlvbiB0byBmb3JtYXQgdGltZSBzdGFtcHMgZm9yIGJvdHRvbSBvZiBjaGFydFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHlvdSBtYXkgdXNlIFNtb290aGllQ2hhcnQudGltZUZvcm1hdHRlciwgb3IgeW91ciBvd246IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuICcnOyB9XG4gICAqICAgc2Nyb2xsQmFja3dhcmRzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gcmV2ZXJzZSB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgY2hhcnRcbiAgICogICBob3Jpem9udGFsTGluZXM6IFtdLCAgICAgICAgICAgICAgICAgICAgICAvLyBbIHsgdmFsdWU6IDAsIGNvbG9yOiAnI2ZmZmZmZicsIGxpbmVXaWR0aDogMSB9IF1cbiAgICogICBncmlkOlxuICAgKiAgIHtcbiAgICogICAgIGZpbGxTdHlsZTogJyMwMDAwMDAnLCAgICAgICAgICAgICAgICAgICAvLyB0aGUgYmFja2dyb3VuZCBjb2xvdXIgb2YgdGhlIGNoYXJ0XG4gICAqICAgICBsaW5lV2lkdGg6IDEsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpeGVsIHdpZHRoIG9mIGdyaWQgbGluZXNcbiAgICogICAgIHN0cm9rZVN0eWxlOiAnIzc3Nzc3NycsICAgICAgICAgICAgICAgICAvLyBjb2xvdXIgb2YgZ3JpZCBsaW5lc1xuICAgKiAgICAgbWlsbGlzUGVyTGluZTogMTAwMCwgICAgICAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgKiAgICAgc2hhcnBMaW5lczogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2xzIHdoZXRoZXIgZ3JpZCBsaW5lcyBhcmUgMXB4IHNoYXJwLCBvciBzb2Z0ZW5lZFxuICAgKiAgICAgdmVydGljYWxTZWN0aW9uczogMiwgICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiB2ZXJ0aWNhbCBzZWN0aW9ucyBtYXJrZWQgb3V0IGJ5IGhvcml6b250YWwgZ3JpZCBsaW5lc1xuICAgKiAgICAgYm9yZGVyVmlzaWJsZTogdHJ1ZSAgICAgICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIGdyaWQgbGluZXMgdHJhY2UgdGhlIGJvcmRlciBvZiB0aGUgY2hhcnQgb3Igbm90XG4gICAqICAgfSxcbiAgICogICBsYWJlbHNcbiAgICogICB7XG4gICAqICAgICBkaXNhYmxlZDogZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5hYmxlcy9kaXNhYmxlcyBsYWJlbHMgc2hvd2luZyB0aGUgbWluL21heCB2YWx1ZXNcbiAgICogICAgIGZpbGxTdHlsZTogJyNmZmZmZmYnLCAgICAgICAgICAgICAgICAgICAvLyBjb2xvdXIgZm9yIHRleHQgb2YgbGFiZWxzLFxuICAgKiAgICAgZm9udFNpemU6IDE1LFxuICAgKiAgICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgKiAgICAgcHJlY2lzaW9uOiAyLFxuICAgKiAgICAgc2hvd0ludGVybWVkaWF0ZUxhYmVsczogZmFsc2UsICAgICAgICAgIC8vIHNob3dzIGludGVybWVkaWF0ZSBsYWJlbHMgYmV0d2VlbiBtaW4gYW5kIG1heCB2YWx1ZXMgYWxvbmcgeSBheGlzXG4gICAqICAgICBpbnRlcm1lZGlhdGVMYWJlbFNhbWVBeGlzOiB0cnVlLFxuICAgKiAgIH0sXG4gICAqICAgdG9vbHRpcDogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdyB0b29sdGlwIHdoZW4gbW91c2UgaXMgb3ZlciB0aGUgY2hhcnRcbiAgICogICB0b29sdGlwTGluZTogeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIGZvciBhIHZlcnRpY2FsIGxpbmUgYXQgdGhlIGN1cnNvciBwb3NpdGlvblxuICAgKiAgICAgbGluZVdpZHRoOiAxLFxuICAgKiAgICAgc3Ryb2tlU3R5bGU6ICcjQkJCQkJCJ1xuICAgKiAgIH0sXG4gICAqICAgdG9vbHRpcEZvcm1hdHRlcjogU21vb3RoaWVDaGFydC50b29sdGlwRm9ybWF0dGVyLCAvLyBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIHRvb2x0aXAgdGV4dFxuICAgKiAgIG5vblJlYWx0aW1lRGF0YTogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aW1lIG9mIGxhdGVzdCBkYXRhIGFzIGN1cnJlbnQgdGltZVxuICAgKiAgIGRpc3BsYXlEYXRhRnJvbVBlcmNlbnRpbGU6IDEsICAgICAgICAgICAgIC8vIGRpc3BsYXkgbm90IGxhdGVzdCBkYXRhLCBidXQgZGF0YSBmcm9tIHRoZSBnaXZlbiBwZXJjZW50aWxlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlZnVsIHdoZW4gdHJ5aW5nIHRvIHNlZSBvbGQgZGF0YSBzYXZlZCBieSBzZXR0aW5nIGEgaGlnaCB2YWx1ZSBmb3IgbWF4RGF0YVNldExlbmd0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgKiAgIHJlc3BvbnNpdmU6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIGNoYXJ0IHNob3VsZCBhZGFwdCB0byB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzXG4gICAqICAgbGltaXRGUFM6IDAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF4aW11bSBmcmFtZSByYXRlIHRoZSBjaGFydCB3aWxsIHJlbmRlciBhdCwgaW4gRlBTICh6ZXJvIG1lYW5zIG5vIGxpbWl0KVxuICAgKiB9XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFNtb290aGllQ2hhcnQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IFV0aWwuZXh0ZW5kKHt9LCBTbW9vdGhpZUNoYXJ0LmRlZmF1bHRDaGFydE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2VyaWVzU2V0ID0gW107XG4gICAgdGhpcy5jdXJyZW50VmFsdWVSYW5nZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50VmlzTWluVmFsdWUgPSAwO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWVNaWxsaXMgPSAwO1xuICAgIHRoaXMubGFzdENoYXJ0VGltZXN0YW1wID0gMDtcblxuICAgIHRoaXMubW91c2Vtb3ZlID0gdGhpcy5tb3VzZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1vdXNlb3V0ID0gdGhpcy5tb3VzZW91dC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqIEZvcm1hdHMgdGhlIEhUTUwgc3RyaW5nIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAuICovXG4gIFNtb290aGllQ2hhcnQudG9vbHRpcEZvcm1hdHRlciA9IGZ1bmN0aW9uICh0aW1lc3RhbXAsIGRhdGEpIHtcbiAgICAgIHZhciB0aW1lc3RhbXBGb3JtYXR0ZXIgPSB0aGlzLm9wdGlvbnMudGltZXN0YW1wRm9ybWF0dGVyIHx8IFNtb290aGllQ2hhcnQudGltZUZvcm1hdHRlcixcbiAgICAgICAgICBsaW5lcyA9IFt0aW1lc3RhbXBGb3JtYXR0ZXIobmV3IERhdGUodGltZXN0YW1wKSldO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGluZXMucHVzaCgnPHNwYW4gc3R5bGU9XCJjb2xvcjonICsgZGF0YVtpXS5zZXJpZXMub3B0aW9ucy5zdHJva2VTdHlsZSArICdcIj4nICtcbiAgICAgICAgdGhpcy5vcHRpb25zLnlNYXhGb3JtYXR0ZXIoZGF0YVtpXS52YWx1ZSwgdGhpcy5vcHRpb25zLmxhYmVscy5wcmVjaXNpb24pICsgJzwvc3Bhbj4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgfTtcblxuICBTbW9vdGhpZUNoYXJ0LmRlZmF1bHRDaGFydE9wdGlvbnMgPSB7XG4gICAgbWlsbGlzUGVyUGl4ZWw6IDIwLFxuICAgIGVuYWJsZURwaVNjYWxpbmc6IHRydWUsXG4gICAgeU1pbkZvcm1hdHRlcjogZnVuY3Rpb24obWluLCBwcmVjaXNpb24pIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1pbikudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH0sXG4gICAgeU1heEZvcm1hdHRlcjogZnVuY3Rpb24obWF4LCBwcmVjaXNpb24pIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1heCkudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH0sXG4gICAgeUludGVybWVkaWF0ZUZvcm1hdHRlcjogZnVuY3Rpb24oaW50ZXJtZWRpYXRlLCBwcmVjaXNpb24pIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGludGVybWVkaWF0ZSkudG9GaXhlZChwcmVjaXNpb24pO1xuICAgIH0sXG4gICAgbWF4VmFsdWVTY2FsZTogMSxcbiAgICBtaW5WYWx1ZVNjYWxlOiAxLFxuICAgIGludGVycG9sYXRpb246ICdiZXppZXInLFxuICAgIHNjYWxlU21vb3RoaW5nOiAwLjEyNSxcbiAgICBtYXhEYXRhU2V0TGVuZ3RoOiAyLFxuICAgIHNjcm9sbEJhY2t3YXJkczogZmFsc2UsXG4gICAgZGlzcGxheURhdGFGcm9tUGVyY2VudGlsZTogMSxcbiAgICBncmlkOiB7XG4gICAgICBmaWxsU3R5bGU6ICcjMDAwMDAwJyxcbiAgICAgIHN0cm9rZVN0eWxlOiAnIzc3Nzc3NycsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzaGFycExpbmVzOiBmYWxzZSxcbiAgICAgIG1pbGxpc1BlckxpbmU6IDEwMDAsXG4gICAgICB2ZXJ0aWNhbFNlY3Rpb25zOiAyLFxuICAgICAgYm9yZGVyVmlzaWJsZTogdHJ1ZVxuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICBmaWxsU3R5bGU6ICcjZmZmZmZmJyxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIGZvbnRTaXplOiAxMCxcbiAgICAgIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UnLFxuICAgICAgcHJlY2lzaW9uOiAyLFxuICAgICAgc2hvd0ludGVybWVkaWF0ZUxhYmVsczogZmFsc2UsXG4gICAgICBpbnRlcm1lZGlhdGVMYWJlbFNhbWVBeGlzOiB0cnVlLFxuICAgIH0sXG4gICAgaG9yaXpvbnRhbExpbmVzOiBbXSxcbiAgICB0b29sdGlwOiBmYWxzZSxcbiAgICB0b29sdGlwTGluZToge1xuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgc3Ryb2tlU3R5bGU6ICcjQkJCQkJCJ1xuICAgIH0sXG4gICAgdG9vbHRpcEZvcm1hdHRlcjogU21vb3RoaWVDaGFydC50b29sdGlwRm9ybWF0dGVyLFxuICAgIG5vblJlYWx0aW1lRGF0YTogZmFsc2UsXG4gICAgcmVzcG9uc2l2ZTogZmFsc2UsXG4gICAgbGltaXRGUFM6IDBcbiAgfTtcblxuICAvLyBCYXNlZCBvbiBodHRwOi8vaW5zcGlyaXQuZ2l0aHViLmNvbS9qc2ZlYXQvanMvY29tcGF0aWJpbGl0eS5qc1xuICBTbW9vdGhpZUNoYXJ0LkFuaW1hdGVDb21wYXRpYmlsaXR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICAgIH0sIDE2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgY2FsbGJhY2ssIGVsZW1lbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBpZCk7XG4gICAgICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZTogY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgICB9O1xuICB9KSgpO1xuXG4gIFNtb290aGllQ2hhcnQuZGVmYXVsdFNlcmllc1ByZXNlbnRhdGlvbk9wdGlvbnMgPSB7XG4gICAgbGluZVdpZHRoOiAxLFxuICAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZidcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIDxjb2RlPlRpbWVTZXJpZXM8L2NvZGU+IHRvIHRoaXMgY2hhcnQsIHdpdGggb3B0aW9uYWwgcHJlc2VudGF0aW9uIG9wdGlvbnMuXG4gICAqXG4gICAqIFByZXNlbnRhdGlvbiBvcHRpb25zIHNob3VsZCBiZSBvZiB0aGUgZm9ybSAoZGVmYXVsdHMgc2hvd24pOlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiB7XG4gICAqICAgbGluZVdpZHRoOiAxLFxuICAgKiAgIHN0cm9rZVN0eWxlOiAnI2ZmZmZmZicsXG4gICAqICAgZmlsbFN0eWxlOiB1bmRlZmluZWRcbiAgICogfVxuICAgKiA8L3ByZT5cbiAgICovXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLmFkZFRpbWVTZXJpZXMgPSBmdW5jdGlvbih0aW1lU2VyaWVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zZXJpZXNTZXQucHVzaCh7dGltZVNlcmllczogdGltZVNlcmllcywgb3B0aW9uczogVXRpbC5leHRlbmQoe30sIFNtb290aGllQ2hhcnQuZGVmYXVsdFNlcmllc1ByZXNlbnRhdGlvbk9wdGlvbnMsIG9wdGlvbnMpfSk7XG4gICAgaWYgKHRpbWVTZXJpZXMub3B0aW9ucy5yZXNldEJvdW5kcyAmJiB0aW1lU2VyaWVzLm9wdGlvbnMucmVzZXRCb3VuZHNJbnRlcnZhbCA+IDApIHtcbiAgICAgIHRpbWVTZXJpZXMucmVzZXRCb3VuZHNUaW1lcklkID0gc2V0SW50ZXJ2YWwoXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRpbWVTZXJpZXMucmVzZXRCb3VuZHMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGltZVNlcmllcy5vcHRpb25zLnJlc2V0Qm91bmRzSW50ZXJ2YWxcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgPGNvZGU+VGltZVNlcmllczwvY29kZT4gZnJvbSB0aGUgY2hhcnQuXG4gICAqL1xuICBTbW9vdGhpZUNoYXJ0LnByb3RvdHlwZS5yZW1vdmVUaW1lU2VyaWVzID0gZnVuY3Rpb24odGltZVNlcmllcykge1xuICAgIC8vIEZpbmQgdGhlIGNvcnJlY3QgdGltZXNlcmllcyB0byByZW1vdmUsIGFuZCByZW1vdmUgaXRcbiAgICB2YXIgbnVtU2VyaWVzID0gdGhpcy5zZXJpZXNTZXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VyaWVzOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnNlcmllc1NldFtpXS50aW1lU2VyaWVzID09PSB0aW1lU2VyaWVzKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzU2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGEgdGltZXIgd2FzIG9wZXJhdGluZyBmb3IgdGhhdCB0aW1lc2VyaWVzLCByZW1vdmUgaXRcbiAgICBpZiAodGltZVNlcmllcy5yZXNldEJvdW5kc1RpbWVySWQpIHtcbiAgICAgIC8vIFN0b3AgcmVzZXR0aW5nIHRoZSBib3VuZHMsIGlmIHdlIHdlcmVcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZVNlcmllcy5yZXNldEJvdW5kc1RpbWVySWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyByZW5kZXIgb3B0aW9ucyBmb3IgdGhlIHNwZWNpZmllZCA8Y29kZT5UaW1lU2VyaWVzPC9jb2RlPi5cbiAgICpcbiAgICogQXMgeW91IG1heSB1c2UgYSBzaW5nbGUgPGNvZGU+VGltZVNlcmllczwvY29kZT4gaW4gbXVsdGlwbGUgY2hhcnRzIHdpdGggZGlmZmVyZW50IGZvcm1hdHRpbmcgaW4gZWFjaCB1c2FnZSxcbiAgICogdGhlc2Ugc2V0dGluZ3MgYXJlIHN0b3JlZCBpbiB0aGUgY2hhcnQuXG4gICAqL1xuICBTbW9vdGhpZUNoYXJ0LnByb3RvdHlwZS5nZXRUaW1lU2VyaWVzT3B0aW9ucyA9IGZ1bmN0aW9uKHRpbWVTZXJpZXMpIHtcbiAgICAvLyBGaW5kIHRoZSBjb3JyZWN0IHRpbWVzZXJpZXMgdG8gcmVtb3ZlLCBhbmQgcmVtb3ZlIGl0XG4gICAgdmFyIG51bVNlcmllcyA9IHRoaXMuc2VyaWVzU2V0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlcmllczsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5zZXJpZXNTZXRbaV0udGltZVNlcmllcyA9PT0gdGltZVNlcmllcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJpZXNTZXRbaV0ub3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEJyaW5ncyB0aGUgc3BlY2lmaWVkIDxjb2RlPlRpbWVTZXJpZXM8L2NvZGU+IHRvIHRoZSB0b3Agb2YgdGhlIGNoYXJ0LiBJdCB3aWxsIGJlIHJlbmRlcmVkIGxhc3QuXG4gICAqL1xuICBTbW9vdGhpZUNoYXJ0LnByb3RvdHlwZS5icmluZ1RvRnJvbnQgPSBmdW5jdGlvbih0aW1lU2VyaWVzKSB7XG4gICAgLy8gRmluZCB0aGUgY29ycmVjdCB0aW1lc2VyaWVzIHRvIHJlbW92ZSwgYW5kIHJlbW92ZSBpdFxuICAgIHZhciBudW1TZXJpZXMgPSB0aGlzLnNlcmllc1NldC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZXJpZXM7IGkrKykge1xuICAgICAgaWYgKHRoaXMuc2VyaWVzU2V0W2ldLnRpbWVTZXJpZXMgPT09IHRpbWVTZXJpZXMpIHtcbiAgICAgICAgdmFyIHNldCA9IHRoaXMuc2VyaWVzU2V0LnNwbGljZShpLCAxKTtcbiAgICAgICAgdGhpcy5zZXJpZXNTZXQucHVzaChzZXRbMF0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc3RydWN0cyB0aGUgPGNvZGU+U21vb3RoaWVDaGFydDwvY29kZT4gdG8gc3RhcnQgcmVuZGVyaW5nIHRvIHRoZSBwcm92aWRlZCBjYW52YXMsIHdpdGggc3BlY2lmaWVkIGRlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gY2FudmFzIHRoZSB0YXJnZXQgY2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIGRlbGF5TWlsbGlzIGFuIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGEgZGF0YSBwb2ludCBpcyBzaG93bi4gVGhpcyBjYW4gcHJldmVudCB0aGUgZW5kIG9mIHRoZSBzZXJpZXNcbiAgICogZnJvbSBhcHBlYXJpbmcgb24gc2NyZWVuLCB3aXRoIG5ldyB2YWx1ZXMgZmxhc2hpbmcgaW50byB2aWV3LCBhdCB0aGUgZXhwZW5zZSBvZiBzb21lIGxhdGVuY3kuXG4gICAqL1xuICBTbW9vdGhpZUNoYXJ0LnByb3RvdHlwZS5zdHJlYW1UbyA9IGZ1bmN0aW9uKGNhbnZhcywgZGVsYXlNaWxsaXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXlNaWxsaXM7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9O1xuXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLmdldFRvb2x0aXBFbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHRvb2wgdGlwIGVsZW1lbnQgbGF6aWx5XG4gICAgaWYgKCF0aGlzLnRvb2x0aXBFbCkge1xuICAgICAgdGhpcy50b29sdGlwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMudG9vbHRpcEVsLmNsYXNzTmFtZSA9ICdzbW9vdGhpZS1jaGFydC10b29sdGlwJztcbiAgICAgIHRoaXMudG9vbHRpcEVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHRoaXMudG9vbHRpcEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMudG9vbHRpcEVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9vbHRpcEVsO1xuICB9O1xuXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLnVwZGF0ZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5nZXRUb29sdGlwRWwoKTtcblxuICAgIGlmICghdGhpcy5tb3VzZW92ZXIgfHwgIXRoaXMub3B0aW9ucy50b29sdGlwKSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0aW1lID0gdGhpcy5sYXN0Q2hhcnRUaW1lc3RhbXA7XG5cbiAgICAvLyB4IHBpeGVsIHRvIHRpbWVcbiAgICB2YXIgdCA9IHRoaXMub3B0aW9ucy5zY3JvbGxCYWNrd2FyZHNcbiAgICAgID8gdGltZSAtIHRoaXMubW91c2VYICogdGhpcy5vcHRpb25zLm1pbGxpc1BlclBpeGVsXG4gICAgICA6IHRpbWUgLSAodGhpcy5jYW52YXMub2Zmc2V0V2lkdGggLSB0aGlzLm1vdXNlWCkgKiB0aGlzLm9wdGlvbnMubWlsbGlzUGVyUGl4ZWw7XG5cbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgIC8vIEZvciBlYWNoIGRhdGEgc2V0Li4uXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCB0aGlzLnNlcmllc1NldC5sZW5ndGg7IGQrKykge1xuICAgICAgdmFyIHRpbWVTZXJpZXMgPSB0aGlzLnNlcmllc1NldFtkXS50aW1lU2VyaWVzO1xuICAgICAgaWYgKHRpbWVTZXJpZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBkYXRhcG9pbnQgY2xvc2VzdCB0byB0aW1lICd0J1xuICAgICAgdmFyIGNsb3NlSWR4ID0gVXRpbC5iaW5hcnlTZWFyY2godGltZVNlcmllcy5kYXRhLCB0KTtcbiAgICAgIGlmIChjbG9zZUlkeCA+IDAgJiYgY2xvc2VJZHggPCB0aW1lU2VyaWVzLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGRhdGEucHVzaCh7IHNlcmllczogdGhpcy5zZXJpZXNTZXRbZF0sIGluZGV4OiBjbG9zZUlkeCwgdmFsdWU6IHRpbWVTZXJpZXMuZGF0YVtjbG9zZUlkeF1bMV0gfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMudG9vbHRpcEZvcm1hdHRlci5jYWxsKHRoaXMsIHQsIGRhdGEpO1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICB9O1xuXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICB0aGlzLm1vdXNlb3ZlciA9IHRydWU7XG4gICAgdGhpcy5tb3VzZVggPSBldnQub2Zmc2V0WDtcbiAgICB0aGlzLm1vdXNlWSA9IGV2dC5vZmZzZXRZO1xuICAgIHRoaXMubW91c2VQYWdlWCA9IGV2dC5wYWdlWDtcbiAgICB0aGlzLm1vdXNlUGFnZVkgPSBldnQucGFnZVk7XG5cbiAgICB2YXIgZWwgPSB0aGlzLmdldFRvb2x0aXBFbCgpO1xuICAgIGVsLnN0eWxlLnRvcCA9IE1hdGgucm91bmQodGhpcy5tb3VzZVBhZ2VZKSArICdweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQodGhpcy5tb3VzZVBhZ2VYKSArICdweCc7XG4gICAgdGhpcy51cGRhdGVUb29sdGlwKCk7XG4gIH07XG5cbiAgU21vb3RoaWVDaGFydC5wcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tb3VzZW92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLm1vdXNlWCA9IHRoaXMubW91c2VZID0gLTE7XG4gICAgaWYgKHRoaXMudG9vbHRpcEVsKVxuICAgICAgdGhpcy50b29sdGlwRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBzdXJlIHRoZSBjYW52YXMgaGFzIHRoZSBvcHRpbWFsIHJlc29sdXRpb24gZm9yIHRoZSBkZXZpY2UncyBwaXhlbCByYXRpby5cbiAgICovXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZHByID0gIXRoaXMub3B0aW9ucy5lbmFibGVEcGlTY2FsaW5nIHx8ICF3aW5kb3cgPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICAvLyBOZXdlciBiZWhhdmlvdXI6IFVzZSB0aGUgY2FudmFzJ3Mgc2l6ZSBpbiB0aGUgbGF5b3V0LCBhbmQgc2V0IHRoZSBpbnRlcm5hbFxuICAgICAgLy8gcmVzb2x1dGlvbiBhY2NvcmRpbmcgdG8gdGhhdCBzaXplIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIChlZzogaGlnaCBEUEkpXG4gICAgICB3aWR0aCA9IHRoaXMuY2FudmFzLm9mZnNldFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5jYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBpZiAod2lkdGggIT09IHRoaXMubGFzdFdpZHRoKSB7XG4gICAgICAgIHRoaXMubGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAoTWF0aC5mbG9vcih3aWR0aCAqIGRwcikpLnRvU3RyaW5nKCkpO1xuICAgICAgICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNjYWxlKGRwciwgZHByKTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQgIT09IHRoaXMubGFzdEhlaWdodCkge1xuICAgICAgICB0aGlzLmxhc3RIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgKE1hdGguZmxvb3IoaGVpZ2h0ICogZHByKSkudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHByICE9PSAxKSB7XG4gICAgICAvLyBPbGRlciBiZWhhdmlvdXI6IHVzZSB0aGUgY2FudmFzJ3MgaW5uZXIgZGltZW5zaW9ucyBhbmQgc2NhbGUgdGhlIGVsZW1lbnQncyBzaXplXG4gICAgICAvLyBhY2NvcmRpbmcgdG8gdGhhdCBzaXplIGFuZCB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvIChlZzogaGlnaCBEUEkpXG4gICAgICB3aWR0aCA9IHBhcnNlSW50KHRoaXMuY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgICBoZWlnaHQgPSBwYXJzZUludCh0aGlzLmNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcblxuICAgICAgaWYgKCF0aGlzLm9yaWdpbmFsV2lkdGggfHwgKE1hdGguZmxvb3IodGhpcy5vcmlnaW5hbFdpZHRoICogZHByKSAhPT0gd2lkdGgpKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxXaWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgKE1hdGguZmxvb3Iod2lkdGggKiBkcHIpKS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJykuc2NhbGUoZHByLCBkcHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3JpZ2luYWxIZWlnaHQgfHwgKE1hdGguZmxvb3IodGhpcy5vcmlnaW5hbEhlaWdodCAqIGRwcikgIT09IGhlaWdodCkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAoTWF0aC5mbG9vcihoZWlnaHQgKiBkcHIpKS50b1N0cmluZygpKTtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zY2FsZShkcHIsIGRwcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIGFuaW1hdGlvbiBvZiB0aGlzIGNoYXJ0LlxuICAgKi9cbiAgU21vb3RoaWVDaGFydC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5mcmFtZSkge1xuICAgICAgLy8gV2UncmUgYWxyZWFkeSBydW5uaW5nLCBzbyBqdXN0IHJldHVyblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMubW91c2VvdXQpO1xuXG4gICAgLy8gUmVuZGVycyBhIGZyYW1lLCBhbmQgcXVldWVzIHRoZSBuZXh0IGZyYW1lIGZvciBsYXRlciByZW5kZXJpbmdcbiAgICB2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5mcmFtZSA9IFNtb290aGllQ2hhcnQuQW5pbWF0ZUNvbXBhdGliaWxpdHkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLm9wdGlvbnMubm9uUmVhbHRpbWVEYXRhKXtcbiAgICAgICAgICAgdmFyIGRhdGVaZXJvID0gbmV3IERhdGUoMCk7XG4gICAgICAgICAgIC8vIGZpbmQgdGhlIGRhdGEgcG9pbnQgd2l0aCB0aGUgbGF0ZXN0IHRpbWVzdGFtcFxuICAgICAgICAgICB2YXIgbWF4VGltZVN0YW1wID0gdGhpcy5zZXJpZXNTZXQucmVkdWNlKGZ1bmN0aW9uKG1heCwgc2VyaWVzKXtcbiAgICAgICAgICAgICB2YXIgZGF0YVNldCA9IHNlcmllcy50aW1lU2VyaWVzLmRhdGE7XG4gICAgICAgICAgICAgdmFyIGluZGV4VG9DaGVjayA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLmRpc3BsYXlEYXRhRnJvbVBlcmNlbnRpbGUgKiBkYXRhU2V0Lmxlbmd0aCkgLSAxO1xuICAgICAgICAgICAgIGluZGV4VG9DaGVjayA9IGluZGV4VG9DaGVjayA+PSAwID8gaW5kZXhUb0NoZWNrIDogMDtcbiAgICAgICAgICAgICBpbmRleFRvQ2hlY2sgPSBpbmRleFRvQ2hlY2sgPD0gZGF0YVNldC5sZW5ndGggLTEgPyBpbmRleFRvQ2hlY2sgOiBkYXRhU2V0Lmxlbmd0aCAtMTtcbiAgICAgICAgICAgICBpZihkYXRhU2V0ICYmIGRhdGFTZXQubGVuZ3RoID4gMClcbiAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIHRpbWVzdGFtcCBjb3JyZXNwb25kcyB0byBlbGVtZW50IDAgb2YgdGhlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgICAgdmFyIGxhc3REYXRhVGltZVN0YW1wID0gZGF0YVNldFtpbmRleFRvQ2hlY2tdWzBdO1xuICAgICAgICAgICAgICBtYXggPSBtYXggPiBsYXN0RGF0YVRpbWVTdGFtcCA/IG1heCA6IGxhc3REYXRhVGltZVN0YW1wO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICAgIH0uYmluZCh0aGlzKSwgZGF0ZVplcm8pO1xuICAgICAgICAgIC8vIHVzZSB0aGUgbWF4IHRpbWVzdGFtcCBhcyBjdXJyZW50IHRpbWVcbiAgICAgICAgICB0aGlzLnJlbmRlcih0aGlzLmNhbnZhcywgbWF4VGltZVN0YW1wID4gZGF0ZVplcm8gPyBtYXhUaW1lU3RhbXAgOiBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGUoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgYW5pbWF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uIG9mIHRoaXMgY2hhcnQuXG4gICAqL1xuICBTbW9vdGhpZUNoYXJ0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZnJhbWUpIHtcbiAgICAgIFNtb290aGllQ2hhcnQuQW5pbWF0ZUNvbXBhdGliaWxpdHkuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mcmFtZSk7XG4gICAgICBkZWxldGUgdGhpcy5mcmFtZTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2Vtb3ZlKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5tb3VzZW91dCk7XG4gICAgfVxuICB9O1xuXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLnVwZGF0ZVZhbHVlUmFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgc2NhbGUgb2YgdGhlIGNoYXJ0LCBmcm9tIGFsbCB0aW1lIHNlcmllcy5cbiAgICB2YXIgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjaGFydE1heFZhbHVlID0gTnVtYmVyLk5hTixcbiAgICAgICAgY2hhcnRNaW5WYWx1ZSA9IE51bWJlci5OYU47XG5cbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IHRoaXMuc2VyaWVzU2V0Lmxlbmd0aDsgZCsrKSB7XG4gICAgICAvLyBUT0RPKG5kdW5uKTogV2UgY291bGQgY2FsY3VsYXRlIC8gdHJhY2sgdGhlc2UgdmFsdWVzIGFzIHRoZXkgc3RyZWFtIGluLlxuICAgICAgdmFyIHRpbWVTZXJpZXMgPSB0aGlzLnNlcmllc1NldFtkXS50aW1lU2VyaWVzO1xuICAgICAgaWYgKHRpbWVTZXJpZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTih0aW1lU2VyaWVzLm1heFZhbHVlKSkge1xuICAgICAgICBjaGFydE1heFZhbHVlID0gIWlzTmFOKGNoYXJ0TWF4VmFsdWUpID8gTWF0aC5tYXgoY2hhcnRNYXhWYWx1ZSwgdGltZVNlcmllcy5tYXhWYWx1ZSkgOiB0aW1lU2VyaWVzLm1heFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKHRpbWVTZXJpZXMubWluVmFsdWUpKSB7XG4gICAgICAgIGNoYXJ0TWluVmFsdWUgPSAhaXNOYU4oY2hhcnRNaW5WYWx1ZSkgPyBNYXRoLm1pbihjaGFydE1pblZhbHVlLCB0aW1lU2VyaWVzLm1pblZhbHVlKSA6IHRpbWVTZXJpZXMubWluVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2NhbGUgdGhlIGNoYXJ0TWF4VmFsdWUgdG8gYWRkIHBhZGRpbmcgYXQgdGhlIHRvcCBpZiByZXF1aXJlZFxuICAgIGlmIChjaGFydE9wdGlvbnMubWF4VmFsdWUgIT0gbnVsbCkge1xuICAgICAgY2hhcnRNYXhWYWx1ZSA9IGNoYXJ0T3B0aW9ucy5tYXhWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcnRNYXhWYWx1ZSAqPSBjaGFydE9wdGlvbnMubWF4VmFsdWVTY2FsZTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIG1pbmltdW0gaWYgd2UndmUgc3BlY2lmaWVkIG9uZVxuICAgIGlmIChjaGFydE9wdGlvbnMubWluVmFsdWUgIT0gbnVsbCkge1xuICAgICAgY2hhcnRNaW5WYWx1ZSA9IGNoYXJ0T3B0aW9ucy5taW5WYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhcnRNaW5WYWx1ZSAtPSBNYXRoLmFicyhjaGFydE1pblZhbHVlICogY2hhcnRPcHRpb25zLm1pblZhbHVlU2NhbGUgLSBjaGFydE1pblZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIGN1c3RvbSByYW5nZSBmdW5jdGlvbiBpcyBzZXQsIGNhbGwgaXRcbiAgICBpZiAodGhpcy5vcHRpb25zLnlSYW5nZUZ1bmN0aW9uKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLm9wdGlvbnMueVJhbmdlRnVuY3Rpb24oe21pbjogY2hhcnRNaW5WYWx1ZSwgbWF4OiBjaGFydE1heFZhbHVlfSk7XG4gICAgICBjaGFydE1pblZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgY2hhcnRNYXhWYWx1ZSA9IHJhbmdlLm1heDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGNoYXJ0TWF4VmFsdWUpICYmICFpc05hTihjaGFydE1pblZhbHVlKSkge1xuICAgICAgdmFyIHRhcmdldFZhbHVlUmFuZ2UgPSBjaGFydE1heFZhbHVlIC0gY2hhcnRNaW5WYWx1ZTtcbiAgICAgIHZhciB2YWx1ZVJhbmdlRGlmZiA9ICh0YXJnZXRWYWx1ZVJhbmdlIC0gdGhpcy5jdXJyZW50VmFsdWVSYW5nZSk7XG4gICAgICB2YXIgbWluVmFsdWVEaWZmID0gKGNoYXJ0TWluVmFsdWUgLSB0aGlzLmN1cnJlbnRWaXNNaW5WYWx1ZSk7XG4gICAgICB0aGlzLmlzQW5pbWF0aW5nU2NhbGUgPSBNYXRoLmFicyh2YWx1ZVJhbmdlRGlmZikgPiAwLjEgfHwgTWF0aC5hYnMobWluVmFsdWVEaWZmKSA+IDAuMTtcbiAgICAgIHRoaXMuY3VycmVudFZhbHVlUmFuZ2UgKz0gY2hhcnRPcHRpb25zLnNjYWxlU21vb3RoaW5nICogdmFsdWVSYW5nZURpZmY7XG4gICAgICB0aGlzLmN1cnJlbnRWaXNNaW5WYWx1ZSArPSBjaGFydE9wdGlvbnMuc2NhbGVTbW9vdGhpbmcgKiBtaW5WYWx1ZURpZmY7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZVJhbmdlID0geyBtaW46IGNoYXJ0TWluVmFsdWUsIG1heDogY2hhcnRNYXhWYWx1ZSB9O1xuICB9O1xuXG4gIFNtb290aGllQ2hhcnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGNhbnZhcywgdGltZSkge1xuICAgIHZhciBub3dNaWxsaXMgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gUmVzcGVjdCBhbnkgZnJhbWUgcmF0ZSBsaW1pdC5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbWl0RlBTID4gMCAmJiBub3dNaWxsaXMgLSB0aGlzLmxhc3RSZW5kZXJUaW1lTWlsbGlzIDwgKDEwMDAvdGhpcy5vcHRpb25zLmxpbWl0RlBTKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICghdGhpcy5pc0FuaW1hdGluZ1NjYWxlKSB7XG4gICAgICAvLyBXZSdyZSBub3QgYW5pbWF0aW5nLiBXZSBjYW4gdXNlIHRoZSBsYXN0IHJlbmRlciB0aW1lIGFuZCB0aGUgc2Nyb2xsIHNwZWVkIHRvIHdvcmsgb3V0IHdoZXRoZXJcbiAgICAgIC8vIHdlIGFjdHVhbGx5IG5lZWQgdG8gcGFpbnQgYW55dGhpbmcgeWV0LiBJZiBub3QsIHdlIGNhbiByZXR1cm4gaW1tZWRpYXRlbHkuXG5cbiAgICAgIC8vIFJlbmRlciBhdCBsZWFzdCBldmVyeSAxLzZ0aCBvZiBhIHNlY29uZC4gVGhlIGNhbnZhcyBtYXkgYmUgcmVzaXplZCwgd2hpY2ggdGhlcmUgaXNcbiAgICAgIC8vIG5vIHJlbGlhYmxlIHdheSB0byBkZXRlY3QuXG4gICAgICB2YXIgbWF4SWRsZU1pbGxpcyA9IE1hdGgubWluKDEwMDAvNiwgdGhpcy5vcHRpb25zLm1pbGxpc1BlclBpeGVsKTtcblxuICAgICAgaWYgKG5vd01pbGxpcyAtIHRoaXMubGFzdFJlbmRlclRpbWVNaWxsaXMgPCBtYXhJZGxlTWlsbGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMudXBkYXRlVG9vbHRpcCgpO1xuXG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZU1pbGxpcyA9IG5vd01pbGxpcztcblxuICAgIGNhbnZhcyA9IGNhbnZhcyB8fCB0aGlzLmNhbnZhcztcbiAgICB0aW1lID0gdGltZSB8fCBub3dNaWxsaXMgLSAodGhpcy5kZWxheSB8fCAwKTtcblxuICAgIC8vIFJvdW5kIHRpbWUgZG93biB0byBwaXhlbCBncmFudWxhcml0eSwgc28gbW90aW9uIGFwcGVhcnMgc21vb3RoZXIuXG4gICAgdGltZSAtPSB0aW1lICUgdGhpcy5vcHRpb25zLm1pbGxpc1BlclBpeGVsO1xuXG4gICAgdGhpcy5sYXN0Q2hhcnRUaW1lc3RhbXAgPSB0aW1lO1xuXG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgY2hhcnRPcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBkaW1lbnNpb25zID0geyB0b3A6IDAsIGxlZnQ6IDAsIHdpZHRoOiBjYW52YXMuY2xpZW50V2lkdGgsIGhlaWdodDogY2FudmFzLmNsaWVudEhlaWdodCB9LFxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRocmVzaG9sZCB0aW1lIGZvciB0aGUgb2xkZXN0IGRhdGEgcG9pbnRzLlxuICAgICAgICBvbGRlc3RWYWxpZFRpbWUgPSB0aW1lIC0gKGRpbWVuc2lvbnMud2lkdGggKiBjaGFydE9wdGlvbnMubWlsbGlzUGVyUGl4ZWwpLFxuICAgICAgICB2YWx1ZVRvWVBpeGVsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gdmFsdWUgLSB0aGlzLmN1cnJlbnRWaXNNaW5WYWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWVSYW5nZSA9PT0gMFxuICAgICAgICAgICAgPyBkaW1lbnNpb25zLmhlaWdodFxuICAgICAgICAgICAgOiBkaW1lbnNpb25zLmhlaWdodCAtIChNYXRoLnJvdW5kKChvZmZzZXQgLyB0aGlzLmN1cnJlbnRWYWx1ZVJhbmdlKSAqIGRpbWVuc2lvbnMuaGVpZ2h0KSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgdGltZVRvWFBpeGVsID0gZnVuY3Rpb24odCkge1xuICAgICAgICAgIGlmKGNoYXJ0T3B0aW9ucy5zY3JvbGxCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aW1lIC0gdCkgLyBjaGFydE9wdGlvbnMubWlsbGlzUGVyUGl4ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaW1lbnNpb25zLndpZHRoIC0gKCh0aW1lIC0gdCkgLyBjaGFydE9wdGlvbnMubWlsbGlzUGVyUGl4ZWwpKTtcbiAgICAgICAgfTtcblxuICAgIHRoaXMudXBkYXRlVmFsdWVSYW5nZSgpO1xuXG4gICAgY29udGV4dC5mb250ID0gY2hhcnRPcHRpb25zLmxhYmVscy5mb250U2l6ZSArICdweCAnICsgY2hhcnRPcHRpb25zLmxhYmVscy5mb250RmFtaWx5O1xuXG4gICAgLy8gU2F2ZSB0aGUgc3RhdGUgb2YgdGhlIGNhbnZhcyBjb250ZXh0LCBhbnkgdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQgaW4gdGhpcyBtZXRob2RcbiAgICAvLyB3aWxsIGdldCByZW1vdmVkIGZyb20gdGhlIHN0YWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBtZXRob2Qgd2hlbiAucmVzdG9yZSgpIGlzIGNhbGxlZC5cbiAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgIC8vIE1vdmUgdGhlIG9yaWdpbi5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShkaW1lbnNpb25zLmxlZnQsIGRpbWVuc2lvbnMudG9wKTtcblxuICAgIC8vIENyZWF0ZSBhIGNsaXBwZWQgcmVjdGFuZ2xlIC0gYW55dGhpbmcgd2UgZHJhdyB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIHRoaXMgcmVjdGFuZ2xlLlxuICAgIC8vIFRoaXMgcHJldmVudHMgdGhlIG9jY2FzaW9uYWwgcGl4ZWxzIGZyb20gY3VydmVzIG5lYXIgdGhlIGVkZ2VzIG92ZXJydW5uaW5nIGFuZCBjcmVhdGluZ1xuICAgIC8vIHNjcmVlbiBjaGVlc2UgKHRoYXQgcGhyYXNlIHNob3VsZCBuZWVkIG5vIGV4cGxhbmF0aW9uKS5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQucmVjdCgwLCAwLCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgY29udGV4dC5jbGlwKCk7XG5cbiAgICAvLyBDbGVhciB0aGUgd29ya2luZyBhcmVhLlxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2hhcnRPcHRpb25zLmdyaWQuZmlsbFN0eWxlO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgIC8vIEdyaWQgbGluZXMuLi5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGNoYXJ0T3B0aW9ucy5ncmlkLmxpbmVXaWR0aDtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2hhcnRPcHRpb25zLmdyaWQuc3Ryb2tlU3R5bGU7XG4gICAgLy8gVmVydGljYWwgKHRpbWUpIGRpdmlkZXJzLlxuICAgIGlmIChjaGFydE9wdGlvbnMuZ3JpZC5taWxsaXNQZXJMaW5lID4gMCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGZvciAodmFyIHQgPSB0aW1lIC0gKHRpbWUgJSBjaGFydE9wdGlvbnMuZ3JpZC5taWxsaXNQZXJMaW5lKTtcbiAgICAgICAgICAgdCA+PSBvbGRlc3RWYWxpZFRpbWU7XG4gICAgICAgICAgIHQgLT0gY2hhcnRPcHRpb25zLmdyaWQubWlsbGlzUGVyTGluZSkge1xuICAgICAgICB2YXIgZ3ggPSB0aW1lVG9YUGl4ZWwodCk7XG4gICAgICAgIGlmIChjaGFydE9wdGlvbnMuZ3JpZC5zaGFycExpbmVzKSB7XG4gICAgICAgICAgZ3ggLT0gMC41O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGd4LCAwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oZ3gsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIC8vIEhvcml6b250YWwgKHZhbHVlKSBkaXZpZGVycy5cbiAgICBmb3IgKHZhciB2ID0gMTsgdiA8IGNoYXJ0T3B0aW9ucy5ncmlkLnZlcnRpY2FsU2VjdGlvbnM7IHYrKykge1xuICAgICAgdmFyIGd5ID0gTWF0aC5yb3VuZCh2ICogZGltZW5zaW9ucy5oZWlnaHQgLyBjaGFydE9wdGlvbnMuZ3JpZC52ZXJ0aWNhbFNlY3Rpb25zKTtcbiAgICAgIGlmIChjaGFydE9wdGlvbnMuZ3JpZC5zaGFycExpbmVzKSB7XG4gICAgICAgIGd5IC09IDAuNTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCBneSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhkaW1lbnNpb25zLndpZHRoLCBneSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgLy8gQm91bmRpbmcgcmVjdGFuZ2xlLlxuICAgIGlmIChjaGFydE9wdGlvbnMuZ3JpZC5ib3JkZXJWaXNpYmxlKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgLy8gRHJhdyBhbnkgaG9yaXpvbnRhbCBsaW5lcy4uLlxuICAgIGlmIChjaGFydE9wdGlvbnMuaG9yaXpvbnRhbExpbmVzICYmIGNoYXJ0T3B0aW9ucy5ob3Jpem9udGFsTGluZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBobCA9IDA7IGhsIDwgY2hhcnRPcHRpb25zLmhvcml6b250YWxMaW5lcy5sZW5ndGg7IGhsKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBjaGFydE9wdGlvbnMuaG9yaXpvbnRhbExpbmVzW2hsXSxcbiAgICAgICAgICAgIGhseSA9IE1hdGgucm91bmQodmFsdWVUb1lQaXhlbChsaW5lLnZhbHVlKSkgLSAwLjU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBsaW5lLmNvbG9yIHx8ICcjZmZmZmZmJztcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCBobHkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhkaW1lbnNpb25zLndpZHRoLCBobHkpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIGRhdGEgc2V0Li4uXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCB0aGlzLnNlcmllc1NldC5sZW5ndGg7IGQrKykge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICB2YXIgdGltZVNlcmllcyA9IHRoaXMuc2VyaWVzU2V0W2RdLnRpbWVTZXJpZXM7XG4gICAgICBpZiAodGltZVNlcmllcy5kaXNhYmxlZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YVNldCA9IHRpbWVTZXJpZXMuZGF0YSxcbiAgICAgICAgICBzZXJpZXNPcHRpb25zID0gdGhpcy5zZXJpZXNTZXRbZF0ub3B0aW9ucztcblxuICAgICAgLy8gRGVsZXRlIG9sZCBkYXRhIHRoYXQncyBtb3ZlZCBvZmYgdGhlIGxlZnQgb2YgdGhlIGNoYXJ0LlxuICAgICAgdGltZVNlcmllcy5kcm9wT2xkRGF0YShvbGRlc3RWYWxpZFRpbWUsIGNoYXJ0T3B0aW9ucy5tYXhEYXRhU2V0TGVuZ3RoKTtcblxuICAgICAgLy8gU2V0IHN0eWxlIGZvciB0aGlzIGRhdGFTZXQuXG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNlcmllc09wdGlvbnMubGluZVdpZHRoO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHNlcmllc09wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICAvLyBEcmF3IHRoZSBsaW5lLi4uXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgLy8gUmV0YWluIGxhc3RYLCBsYXN0WSBmb3IgY2FsY3VsYXRpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIG9mIGJlemllciBjdXJ2ZXMuXG4gICAgICB2YXIgZmlyc3RYID0gMCwgbGFzdFggPSAwLCBsYXN0WSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFTZXQubGVuZ3RoICYmIGRhdGFTZXQubGVuZ3RoICE9PSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSB0aW1lVG9YUGl4ZWwoZGF0YVNldFtpXVswXSksXG4gICAgICAgICAgICB5ID0gdmFsdWVUb1lQaXhlbChkYXRhU2V0W2ldWzFdKTtcblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGZpcnN0WCA9IHg7XG4gICAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChjaGFydE9wdGlvbnMuaW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgICAgICAgY2FzZSBcImxpbmVcIjoge1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJiZXppZXJcIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgLy8gR3JlYXQgZXhwbGFuYXRpb24gb2YgQmV6aWVyIGN1cnZlczogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CZXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBBc3N1bWluZyBBIHdhcyB0aGUgbGFzdCBwb2ludCBpbiB0aGUgbGluZSBwbG90dGVkIGFuZCBCIGlzIHRoZSBuZXcgcG9pbnQsXG4gICAgICAgICAgICAgIC8vIHdlIGRyYXcgYSBjdXJ2ZSB3aXRoIGNvbnRyb2wgcG9pbnRzIFAgYW5kIFEgYXMgYmVsb3cuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEEtLS1QXG4gICAgICAgICAgICAgIC8vICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICBRLS0tQlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBJbXBvcnRhbnRseSwgQSBhbmQgUCBhcmUgYXQgdGhlIHNhbWUgeSBjb29yZGluYXRlLCBhcyBhcmUgQiBhbmQgUS4gVGhpcyBpc1xuICAgICAgICAgICAgICAvLyBzbyBhZGphY2VudCBjdXJ2ZXMgYXBwZWFyIHRvIGZsb3cgYXMgb25lLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oIC8vIHN0YXJ0UG9pbnQgKEEpIGlzIGltcGxpY2l0IGZyb20gbGFzdCBpdGVyYXRpb24gb2YgbG9vcFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKGxhc3RYICsgeCkgLyAyKSwgbGFzdFksIC8vIGNvbnRyb2xQb2ludDEgKFApXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgobGFzdFggKyB4KSkgLyAyLCB5LCAvLyBjb250cm9sUG9pbnQyIChRKVxuICAgICAgICAgICAgICAgIHgsIHkpOyAvLyBlbmRQb2ludCAoQilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RlcFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsbGFzdFkpO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4LHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0WCA9IHg7IGxhc3RZID0geTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFTZXQubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoc2VyaWVzT3B0aW9ucy5maWxsU3R5bGUpIHtcbiAgICAgICAgICAvLyBDbG9zZSB1cCB0aGUgZmlsbCByZWdpb24uXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oZGltZW5zaW9ucy53aWR0aCArIHNlcmllc09wdGlvbnMubGluZVdpZHRoICsgMSwgbGFzdFkpO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKGRpbWVuc2lvbnMud2lkdGggKyBzZXJpZXNPcHRpb25zLmxpbmVXaWR0aCArIDEsIGRpbWVuc2lvbnMuaGVpZ2h0ICsgc2VyaWVzT3B0aW9ucy5saW5lV2lkdGggKyAxKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhmaXJzdFgsIGRpbWVuc2lvbnMuaGVpZ2h0ICsgc2VyaWVzT3B0aW9ucy5saW5lV2lkdGgpO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gc2VyaWVzT3B0aW9ucy5maWxsU3R5bGU7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VyaWVzT3B0aW9ucy5zdHJva2VTdHlsZSAmJiBzZXJpZXNPcHRpb25zLnN0cm9rZVN0eWxlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhcnRPcHRpb25zLnRvb2x0aXAgJiYgdGhpcy5tb3VzZVggPj0gMCkge1xuICAgICAgLy8gRHJhdyB2ZXJ0aWNhbCBiYXIgdG8gc2hvdyB0b29sdGlwIHBvc2l0aW9uXG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGNoYXJ0T3B0aW9ucy50b29sdGlwTGluZS5saW5lV2lkdGg7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2hhcnRPcHRpb25zLnRvb2x0aXBMaW5lLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHRoaXMubW91c2VYLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHRoaXMubW91c2VYLCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIHRoaXMudXBkYXRlVG9vbHRpcCgpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIGF4aXMgdmFsdWVzIG9uIHRoZSBjaGFydC5cbiAgICBpZiAoIWNoYXJ0T3B0aW9ucy5sYWJlbHMuZGlzYWJsZWQgJiYgIWlzTmFOKHRoaXMudmFsdWVSYW5nZS5taW4pICYmICFpc05hTih0aGlzLnZhbHVlUmFuZ2UubWF4KSkge1xuICAgICAgdmFyIG1heFZhbHVlU3RyaW5nID0gY2hhcnRPcHRpb25zLnlNYXhGb3JtYXR0ZXIodGhpcy52YWx1ZVJhbmdlLm1heCwgY2hhcnRPcHRpb25zLmxhYmVscy5wcmVjaXNpb24pLFxuICAgICAgICAgIG1pblZhbHVlU3RyaW5nID0gY2hhcnRPcHRpb25zLnlNaW5Gb3JtYXR0ZXIodGhpcy52YWx1ZVJhbmdlLm1pbiwgY2hhcnRPcHRpb25zLmxhYmVscy5wcmVjaXNpb24pLFxuICAgICAgICAgIG1heExhYmVsUG9zID0gY2hhcnRPcHRpb25zLnNjcm9sbEJhY2t3YXJkcyA/IDAgOiBkaW1lbnNpb25zLndpZHRoIC0gY29udGV4dC5tZWFzdXJlVGV4dChtYXhWYWx1ZVN0cmluZykud2lkdGggLSAyLFxuICAgICAgICAgIG1pbkxhYmVsUG9zID0gY2hhcnRPcHRpb25zLnNjcm9sbEJhY2t3YXJkcyA/IDAgOiBkaW1lbnNpb25zLndpZHRoIC0gY29udGV4dC5tZWFzdXJlVGV4dChtaW5WYWx1ZVN0cmluZykud2lkdGggLSAyO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjaGFydE9wdGlvbnMubGFiZWxzLmZpbGxTdHlsZTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQobWF4VmFsdWVTdHJpbmcsIG1heExhYmVsUG9zLCBjaGFydE9wdGlvbnMubGFiZWxzLmZvbnRTaXplKTtcbiAgICAgIGNvbnRleHQuZmlsbFRleHQobWluVmFsdWVTdHJpbmcsIG1pbkxhYmVsUG9zLCBkaW1lbnNpb25zLmhlaWdodCAtIDIpO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgaW50ZXJtZWRpYXRlIHkgYXhpcyBsYWJlbHMgYWxvbmcgeS1heGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBjaGFydFxuICAgIGlmICggY2hhcnRPcHRpb25zLmxhYmVscy5zaG93SW50ZXJtZWRpYXRlTGFiZWxzXG4gICAgICAgICAgJiYgIWlzTmFOKHRoaXMudmFsdWVSYW5nZS5taW4pICYmICFpc05hTih0aGlzLnZhbHVlUmFuZ2UubWF4KVxuICAgICAgICAgICYmIGNoYXJ0T3B0aW9ucy5ncmlkLnZlcnRpY2FsU2VjdGlvbnMgPiAwKSB7XG4gICAgICAvLyBzaG93IGEgbGFiZWwgYWJvdmUgZXZlcnkgdmVydGljYWwgc2VjdGlvbiBkaXZpZGVyXG4gICAgICB2YXIgc3RlcCA9ICh0aGlzLnZhbHVlUmFuZ2UubWF4IC0gdGhpcy52YWx1ZVJhbmdlLm1pbikgLyBjaGFydE9wdGlvbnMuZ3JpZC52ZXJ0aWNhbFNlY3Rpb25zO1xuICAgICAgdmFyIHN0ZXBQaXhlbHMgPSBkaW1lbnNpb25zLmhlaWdodCAvIGNoYXJ0T3B0aW9ucy5ncmlkLnZlcnRpY2FsU2VjdGlvbnM7XG4gICAgICBmb3IgKHZhciB2ID0gMTsgdiA8IGNoYXJ0T3B0aW9ucy5ncmlkLnZlcnRpY2FsU2VjdGlvbnM7IHYrKykge1xuICAgICAgICB2YXIgZ3kgPSBkaW1lbnNpb25zLmhlaWdodCAtIE1hdGgucm91bmQodiAqIHN0ZXBQaXhlbHMpO1xuICAgICAgICBpZiAoY2hhcnRPcHRpb25zLmdyaWQuc2hhcnBMaW5lcykge1xuICAgICAgICAgIGd5IC09IDAuNTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnRPcHRpb25zLnlJbnRlcm1lZGlhdGVGb3JtYXR0ZXIodGhpcy52YWx1ZVJhbmdlLm1pbiArICh2ICogc3RlcCksIGNoYXJ0T3B0aW9ucy5sYWJlbHMucHJlY2lzaW9uKTtcbiAgICAgICAgLy9sZWZ0IG9mIHJpZ2h0IGF4aXM/XG4gICAgICAgIGludGVybWVkaWF0ZUxhYmVsUG9zID1cbiAgICAgICAgICBjaGFydE9wdGlvbnMubGFiZWxzLmludGVybWVkaWF0ZUxhYmVsU2FtZUF4aXNcbiAgICAgICAgICA/IChjaGFydE9wdGlvbnMuc2Nyb2xsQmFja3dhcmRzID8gMCA6IGRpbWVuc2lvbnMud2lkdGggLSBjb250ZXh0Lm1lYXN1cmVUZXh0KHlWYWx1ZSkud2lkdGggLSAyKVxuICAgICAgICAgIDogKGNoYXJ0T3B0aW9ucy5zY3JvbGxCYWNrd2FyZHMgPyBkaW1lbnNpb25zLndpZHRoIC0gY29udGV4dC5tZWFzdXJlVGV4dCh5VmFsdWUpLndpZHRoIC0gMiA6IDApO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoeVZhbHVlLCBpbnRlcm1lZGlhdGVMYWJlbFBvcywgZ3kgLSBjaGFydE9wdGlvbnMuZ3JpZC5saW5lV2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc3BsYXkgdGltZXN0YW1wcyBhbG9uZyB4LWF4aXMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgY2hhcnQuXG4gICAgaWYgKGNoYXJ0T3B0aW9ucy50aW1lc3RhbXBGb3JtYXR0ZXIgJiYgY2hhcnRPcHRpb25zLmdyaWQubWlsbGlzUGVyTGluZSA+IDApIHtcbiAgICAgIHZhciB0ZXh0VW50aWxYID0gY2hhcnRPcHRpb25zLnNjcm9sbEJhY2t3YXJkc1xuICAgICAgICA/IGNvbnRleHQubWVhc3VyZVRleHQobWluVmFsdWVTdHJpbmcpLndpZHRoXG4gICAgICAgIDogZGltZW5zaW9ucy53aWR0aCAtIGNvbnRleHQubWVhc3VyZVRleHQobWluVmFsdWVTdHJpbmcpLndpZHRoICsgNDtcbiAgICAgIGZvciAodmFyIHQgPSB0aW1lIC0gKHRpbWUgJSBjaGFydE9wdGlvbnMuZ3JpZC5taWxsaXNQZXJMaW5lKTtcbiAgICAgICAgICAgdCA+PSBvbGRlc3RWYWxpZFRpbWU7XG4gICAgICAgICAgIHQgLT0gY2hhcnRPcHRpb25zLmdyaWQubWlsbGlzUGVyTGluZSkge1xuICAgICAgICB2YXIgZ3ggPSB0aW1lVG9YUGl4ZWwodCk7XG4gICAgICAgIC8vIE9ubHkgZHJhdyB0aGUgdGltZXN0YW1wIGlmIGl0IHdvbid0IG92ZXJsYXAgd2l0aCB0aGUgcHJldmlvdXNseSBkcmF3biBvbmUuXG4gICAgICAgIGlmICgoIWNoYXJ0T3B0aW9ucy5zY3JvbGxCYWNrd2FyZHMgJiYgZ3ggPCB0ZXh0VW50aWxYKSB8fCAoY2hhcnRPcHRpb25zLnNjcm9sbEJhY2t3YXJkcyAmJiBneCA+IHRleHRVbnRpbFgpKSAge1xuICAgICAgICAgIC8vIEZvcm1hdHMgdGhlIHRpbWVzdGFtcCBiYXNlZCBvbiB1c2VyIHNwZWNpZmllZCBmb3JtYXR0aW5nIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gU21vb3RoaWVDaGFydC50aW1lRm9ybWF0dGVyIGZ1bmN0aW9uIGFib3ZlIGlzIG9uZSBzdWNoIGZvcm1hdHRpbmcgb3B0aW9uXG4gICAgICAgICAgdmFyIHR4ID0gbmV3IERhdGUodCksXG4gICAgICAgICAgICB0cyA9IGNoYXJ0T3B0aW9ucy50aW1lc3RhbXBGb3JtYXR0ZXIodHgpLFxuICAgICAgICAgICAgdHNXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodHMpLndpZHRoO1xuXG4gICAgICAgICAgdGV4dFVudGlsWCA9IGNoYXJ0T3B0aW9ucy5zY3JvbGxCYWNrd2FyZHNcbiAgICAgICAgICAgID8gZ3ggKyB0c1dpZHRoICsgMlxuICAgICAgICAgICAgOiBneCAtIHRzV2lkdGggLSAyO1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjaGFydE9wdGlvbnMubGFiZWxzLmZpbGxTdHlsZTtcbiAgICAgICAgICBpZihjaGFydE9wdGlvbnMuc2Nyb2xsQmFja3dhcmRzKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRzLCBneCwgZGltZW5zaW9ucy5oZWlnaHQgLSAyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5maWxsVGV4dCh0cywgZ3ggLSB0c1dpZHRoLCBkaW1lbnNpb25zLmhlaWdodCAtIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQucmVzdG9yZSgpOyAvLyBTZWUgLnNhdmUoKSBhYm92ZS5cbiAgfTtcblxuICAvLyBTYW1wbGUgdGltZXN0YW1wIGZvcm1hdHRpbmcgZnVuY3Rpb25cbiAgU21vb3RoaWVDaGFydC50aW1lRm9ybWF0dGVyID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGZ1bmN0aW9uIHBhZDIobnVtYmVyKSB7IHJldHVybiAobnVtYmVyIDwgMTAgPyAnMCcgOiAnJykgKyBudW1iZXIgfVxuICAgIHJldHVybiBwYWQyKGRhdGUuZ2V0SG91cnMoKSkgKyAnOicgKyBwYWQyKGRhdGUuZ2V0TWludXRlcygpKSArICc6JyArIHBhZDIoZGF0ZS5nZXRTZWNvbmRzKCkpO1xuICB9O1xuXG4gIGV4cG9ydHMuVGltZVNlcmllcyA9IFRpbWVTZXJpZXM7XG4gIGV4cG9ydHMuU21vb3RoaWVDaGFydCA9IFNtb290aGllQ2hhcnQ7XG5cbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiBleHBvcnRzKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/smoothie/smoothie.js\n");

/***/ }),

/***/ "./src/lib/components/Smoothie.react.js":
/*!**********************************************!*\
  !*** ./src/lib/components/Smoothie.react.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(/*! react */ \"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _reactSmoothie = __webpack_require__(/*! react-smoothie */ \"./node_modules/react-smoothie/SmoothieComponent.js\");\n\nvar _reactSmoothie2 = _interopRequireDefault(_reactSmoothie);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n// import SmoothieChart from 'smoothie';\n\n\nvar TS = new _reactSmoothie.TimeSeries();\nvar TS2 = new _reactSmoothie.TimeSeries();\n/**\n * ExampleComponent is an example component.\n * It takes a property, `label`, and\n * displays it.\n * It renders an input with the property `value`\n * which is editable by the user.\n */\n\nvar Smoothie = function (_Component) {\n  _inherits(Smoothie, _Component);\n\n  function Smoothie(props) {\n    _classCallCheck(this, Smoothie);\n\n    var _this = _possibleConstructorReturn(this, (Smoothie.__proto__ || Object.getPrototypeOf(Smoothie)).call(this, props));\n\n    _this.state = { millisPerPixel: 10 };\n    return _this;\n  }\n\n  _createClass(Smoothie, [{\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          id = _props.id,\n          label = _props.label,\n          value = _props.value;\n\n      return _react2.default.createElement(\n        'div',\n        { id: id + \"div\" },\n        _react2.default.createElement(\n          'button',\n          { onClick: function onClick() {\n              return _this2.setState({ toggle: !_this2.state.toggle });\n            } },\n          'Toggle Existence'\n        ),\n        _react2.default.createElement(\n          'button',\n          { onClick: function onClick() {\n              return _this2.setState({ delay: (_this2.state.delay || 0) + 500 });\n            } },\n          'Increment Delay'\n        ),\n        _react2.default.createElement(\n          'button',\n          { onClick: function onClick() {\n              return _this2.setState({ delay: (_this2.state.delay || 0) - 500 });\n            } },\n          'Decrement Delay'\n        ),\n        !this.state.toggle ? _react2.default.createElement(_reactSmoothie2.default, {\n          ref: 'chart',\n          responsive: true,\n          interpolation: 'bezier',\n          minValue: 0,\n          maxValue: 1,\n          streamDelay: this.state.delay,\n          millisPerPixel: this.state.millisPerPixel,\n          tooltip: function tooltip(props) {\n            if (!props.display) return _react2.default.createElement('div', null);\n\n            return _react2.default.createElement(\n              'div',\n              {\n                style: {\n                  userSelect: 'none',\n                  background: '#444',\n                  padding: '1em',\n                  marginLeft: '20px',\n                  fontFamily: 'consolas',\n                  color: 'white',\n                  fontSize: '10px',\n                  pointerEvents: 'none'\n                }\n              },\n              _react2.default.createElement(\n                'strong',\n                null,\n                props.time\n              ),\n              props.data ? _react2.default.createElement(\n                'ul',\n                null,\n                props.data.map(function (data, i) {\n                  return _react2.default.createElement(\n                    'li',\n                    { key: i, style: { color: data.series.options.strokeStyle } },\n                    data.value\n                  );\n                })\n              ) : _react2.default.createElement('div', null)\n            );\n          },\n          series: [{\n            data: TS,\n            r: 255,\n            lineWidth: 4\n          }]\n        }) : _react2.default.createElement('div', null),\n        _react2.default.createElement('input', { id: id + \"input\", type: 'range', min: 1, max: 100, defaultValue: 10,\n          onChange: function onChange(e) {\n            return _this2.setState({ millisPerPixel: e.target.value });\n          } })\n      );\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      // var ts1 = this.refs.chart.addTimeSeries({\n      //   strokeStyle: 'rgba(0, 255, 0, 1)',\n      //   fillStyle: 'rgba(0, 255, 0, 0.2)',\n      //   lineWidth: 4,\n      // });\n\n      // this.refs.chart.addTimeSeries(TS2, {\n      //   strokeStyle: { r: 255 },\n      //   fillStyle: { r: 255, a: 0.5 },\n      //   lineWidth: 4,\n      // });\n\n      this.dataGenerator = setInterval(function () {\n        var time = new Date().getTime();\n\n        // Generate times slightly in the future\n        // time += 1000;\n\n        // ts1.append(time, Math.random());\n        // TS2.append(time, Math.random());\n        TS.append(time, Math.random());\n      }, 500);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      clearInterval(this.dataGenerator);\n    }\n  }]);\n\n  return Smoothie;\n}(_react.Component);\n\nexports.default = Smoothie;\n\n\nSmoothie.defaultProps = {};\n\nSmoothie.propTypes = {\n  /**\n   * The ID used to identify this component in Dash callbacks\n   */\n  id: _propTypes2.default.string,\n\n  /**\n   * A label that will be printed when this component is rendered.\n   */\n  label: _propTypes2.default.string.isRequired,\n\n  /**\n   * The value displayed in the input\n   */\n  value: _propTypes2.default.string,\n\n  /**\n   * Dash-assigned callback that should be called whenever any of the\n   * properties change\n   */\n  setProps: _propTypes2.default.func\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vc3JjL2xpYi9jb21wb25lbnRzL1Ntb290aGllLnJlYWN0LmpzP2U0ZWMiXSwibmFtZXMiOlsiVFMiLCJUaW1lU2VyaWVzIiwiVFMyIiwiU21vb3RoaWUiLCJwcm9wcyIsInN0YXRlIiwibWlsbGlzUGVyUGl4ZWwiLCJpZCIsImxhYmVsIiwidmFsdWUiLCJzZXRTdGF0ZSIsInRvZ2dsZSIsImRlbGF5IiwiZGlzcGxheSIsInVzZXJTZWxlY3QiLCJiYWNrZ3JvdW5kIiwicGFkZGluZyIsIm1hcmdpbkxlZnQiLCJmb250RmFtaWx5IiwiY29sb3IiLCJmb250U2l6ZSIsInBvaW50ZXJFdmVudHMiLCJ0aW1lIiwiZGF0YSIsIm1hcCIsImkiLCJzZXJpZXMiLCJvcHRpb25zIiwic3Ryb2tlU3R5bGUiLCJyIiwibGluZVdpZHRoIiwiZSIsInRhcmdldCIsImRhdGFHZW5lcmF0b3IiLCJzZXRJbnRlcnZhbCIsIkRhdGUiLCJnZXRUaW1lIiwiYXBwZW5kIiwiTWF0aCIsInJhbmRvbSIsImNsZWFySW50ZXJ2YWwiLCJDb21wb25lbnQiLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwic2V0UHJvcHMiLCJmdW5jIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFFQTs7Ozs7Ozs7Ozs7QUFEQTs7O0FBR0EsSUFBTUEsS0FBSyxJQUFJQyx5QkFBSixFQUFYO0FBQ0EsSUFBTUMsTUFBTSxJQUFJRCx5QkFBSixFQUFaO0FBQ0E7Ozs7Ozs7O0lBT3FCRSxROzs7QUFDbkIsb0JBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxvSEFDWEEsS0FEVzs7QUFHakIsVUFBS0MsS0FBTCxHQUFhLEVBQUNDLGdCQUFnQixFQUFqQixFQUFiO0FBSGlCO0FBSWxCOzs7OzZCQUVRO0FBQUE7O0FBQUEsbUJBQ29CLEtBQUtGLEtBRHpCO0FBQUEsVUFDQUcsRUFEQSxVQUNBQSxFQURBO0FBQUEsVUFDSUMsS0FESixVQUNJQSxLQURKO0FBQUEsVUFDV0MsS0FEWCxVQUNXQSxLQURYOztBQUVQLGFBQ0U7QUFBQTtBQUFBLFVBQUssSUFBSUYsS0FBRyxLQUFaO0FBQ0U7QUFBQTtBQUFBLFlBQVEsU0FBUztBQUFBLHFCQUFNLE9BQUtHLFFBQUwsQ0FBYyxFQUFFQyxRQUFRLENBQUMsT0FBS04sS0FBTCxDQUFXTSxNQUF0QixFQUFkLENBQU47QUFBQSxhQUFqQjtBQUFBO0FBQUEsU0FERjtBQUVFO0FBQUE7QUFBQSxZQUFRLFNBQVM7QUFBQSxxQkFBTSxPQUFLRCxRQUFMLENBQWMsRUFBRUUsT0FBTyxDQUFDLE9BQUtQLEtBQUwsQ0FBV08sS0FBWCxJQUFvQixDQUFyQixJQUEwQixHQUFuQyxFQUFkLENBQU47QUFBQSxhQUFqQjtBQUFBO0FBQUEsU0FGRjtBQUdFO0FBQUE7QUFBQSxZQUFRLFNBQVM7QUFBQSxxQkFBTSxPQUFLRixRQUFMLENBQWMsRUFBRUUsT0FBTyxDQUFDLE9BQUtQLEtBQUwsQ0FBV08sS0FBWCxJQUFvQixDQUFyQixJQUEwQixHQUFuQyxFQUFkLENBQU47QUFBQSxhQUFqQjtBQUFBO0FBQUEsU0FIRjtBQUlHLFNBQUMsS0FBS1AsS0FBTCxDQUFXTSxNQUFaLEdBQ0MsOEJBQUMsdUJBQUQ7QUFDRSxlQUFJLE9BRE47QUFFRSwwQkFGRjtBQUdFLHlCQUFjLFFBSGhCO0FBSUUsb0JBQVUsQ0FKWjtBQUtFLG9CQUFVLENBTFo7QUFNRSx1QkFBYSxLQUFLTixLQUFMLENBQVdPLEtBTjFCO0FBT0UsMEJBQWdCLEtBQUtQLEtBQUwsQ0FBV0MsY0FQN0I7QUFRRSxtQkFBUyx3QkFBUztBQUNoQixnQkFBSSxDQUFDRixNQUFNUyxPQUFYLEVBQW9CLE9BQU8sMENBQVA7O0FBRXBCLG1CQUNFO0FBQUE7QUFBQTtBQUNFLHVCQUFPO0FBQ0xDLDhCQUFZLE1BRFA7QUFFTEMsOEJBQVksTUFGUDtBQUdMQywyQkFBUyxLQUhKO0FBSUxDLDhCQUFZLE1BSlA7QUFLTEMsOEJBQVksVUFMUDtBQU1MQyx5QkFBTyxPQU5GO0FBT0xDLDRCQUFVLE1BUEw7QUFRTEMsaUNBQWU7QUFSVjtBQURUO0FBWUU7QUFBQTtBQUFBO0FBQVNqQixzQkFBTWtCO0FBQWYsZUFaRjtBQWFHbEIsb0JBQU1tQixJQUFOLEdBQ0M7QUFBQTtBQUFBO0FBQ0duQixzQkFBTW1CLElBQU4sQ0FBV0MsR0FBWCxDQUFlLFVBQUNELElBQUQsRUFBT0UsQ0FBUDtBQUFBLHlCQUNkO0FBQUE7QUFBQSxzQkFBSSxLQUFLQSxDQUFULEVBQVksT0FBTyxFQUFFTixPQUFPSSxLQUFLRyxNQUFMLENBQVlDLE9BQVosQ0FBb0JDLFdBQTdCLEVBQW5CO0FBQ0dMLHlCQUFLZDtBQURSLG1CQURjO0FBQUEsaUJBQWY7QUFESCxlQURELEdBU0M7QUF0QkosYUFERjtBQTJCRCxXQXRDSDtBQXVDRSxrQkFBUSxDQUNOO0FBQ0VjLGtCQUFNdkIsRUFEUjtBQUVFNkIsZUFBRyxHQUZMO0FBR0VDLHVCQUFXO0FBSGIsV0FETTtBQXZDVixVQURELEdBaURDLDBDQXJESjtBQXdERSxpREFBTyxJQUFJdkIsS0FBRyxPQUFkLEVBQXVCLE1BQUssT0FBNUIsRUFBb0MsS0FBSyxDQUF6QyxFQUE0QyxLQUFLLEdBQWpELEVBQXNELGNBQWMsRUFBcEU7QUFDRSxvQkFBVSxrQkFBQ3dCLENBQUQ7QUFBQSxtQkFBTyxPQUFLckIsUUFBTCxDQUFjLEVBQUNKLGdCQUFnQnlCLEVBQUVDLE1BQUYsQ0FBU3ZCLEtBQTFCLEVBQWQsQ0FBUDtBQUFBLFdBRFo7QUF4REYsT0FERjtBQStERDs7O3dDQUVtQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBS3dCLGFBQUwsR0FBcUJDLFlBQVksWUFBVztBQUMxQyxZQUFJWixPQUFPLElBQUlhLElBQUosR0FBV0MsT0FBWCxFQUFYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBcEMsV0FBR3FDLE1BQUgsQ0FBVWYsSUFBVixFQUFnQmdCLEtBQUtDLE1BQUwsRUFBaEI7QUFDRCxPQVRvQixFQVNsQixHQVRrQixDQUFyQjtBQVVEOzs7MkNBRXNCO0FBQ3JCQyxvQkFBYyxLQUFLUCxhQUFuQjtBQUNEOzs7O0VBckdtQ1EsZ0I7O2tCQUFqQnRDLFE7OztBQXdHckJBLFNBQVN1QyxZQUFULEdBQXdCLEVBQXhCOztBQUVBdkMsU0FBU3dDLFNBQVQsR0FBcUI7QUFDakI7OztBQUdBcEMsTUFBSXFDLG9CQUFVQyxNQUpHOztBQU1qQjs7O0FBR0FyQyxTQUFPb0Msb0JBQVVDLE1BQVYsQ0FBaUJDLFVBVFA7O0FBV2pCOzs7QUFHQXJDLFNBQU9tQyxvQkFBVUMsTUFkQTs7QUFnQmpCOzs7O0FBSUFFLFlBQVVILG9CQUFVSTtBQXBCSCxDQUFyQiIsImZpbGUiOiIuL3NyYy9saWIvY29tcG9uZW50cy9TbW9vdGhpZS5yZWFjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbi8vIGltcG9ydCBTbW9vdGhpZUNoYXJ0IGZyb20gJ3Ntb290aGllJztcbmltcG9ydCBTbW9vdGhpZUNvbXBvbmVudCwgeyBUaW1lU2VyaWVzIH0gZnJvbSAncmVhY3Qtc21vb3RoaWUnO1xuXG5jb25zdCBUUyA9IG5ldyBUaW1lU2VyaWVzKCk7XG5jb25zdCBUUzIgPSBuZXcgVGltZVNlcmllcygpO1xuLyoqXG4gKiBFeGFtcGxlQ29tcG9uZW50IGlzIGFuIGV4YW1wbGUgY29tcG9uZW50LlxuICogSXQgdGFrZXMgYSBwcm9wZXJ0eSwgYGxhYmVsYCwgYW5kXG4gKiBkaXNwbGF5cyBpdC5cbiAqIEl0IHJlbmRlcnMgYW4gaW5wdXQgd2l0aCB0aGUgcHJvcGVydHkgYHZhbHVlYFxuICogd2hpY2ggaXMgZWRpdGFibGUgYnkgdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNtb290aGllIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge21pbGxpc1BlclBpeGVsOiAxMH07XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge2lkLCBsYWJlbCwgdmFsdWV9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD17aWQrXCJkaXZcIn0+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IHRvZ2dsZTogIXRoaXMuc3RhdGUudG9nZ2xlIH0pfT5Ub2dnbGUgRXhpc3RlbmNlPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGRlbGF5OiAodGhpcy5zdGF0ZS5kZWxheSB8fCAwKSArIDUwMCB9KX0+SW5jcmVtZW50IERlbGF5PC9idXR0b24+XG4gICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGRlbGF5OiAodGhpcy5zdGF0ZS5kZWxheSB8fCAwKSAtIDUwMCB9KX0+RGVjcmVtZW50IERlbGF5PC9idXR0b24+XG4gICAgICAgIHshdGhpcy5zdGF0ZS50b2dnbGUgPyAoXG4gICAgICAgICAgPFNtb290aGllQ29tcG9uZW50XG4gICAgICAgICAgICByZWY9XCJjaGFydFwiXG4gICAgICAgICAgICByZXNwb25zaXZlXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uPVwiYmV6aWVyXCJcbiAgICAgICAgICAgIG1pblZhbHVlPXswfVxuICAgICAgICAgICAgbWF4VmFsdWU9ezF9XG4gICAgICAgICAgICBzdHJlYW1EZWxheT17dGhpcy5zdGF0ZS5kZWxheX1cbiAgICAgICAgICAgIG1pbGxpc1BlclBpeGVsPXt0aGlzLnN0YXRlLm1pbGxpc1BlclBpeGVsfVxuICAgICAgICAgICAgdG9vbHRpcD17cHJvcHMgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXByb3BzLmRpc3BsYXkpIHJldHVybiA8ZGl2IC8+O1xuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnIzQ0NCcsXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcxZW0nLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdjb25zb2xhcycsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEwcHgnLFxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxzdHJvbmc+e3Byb3BzLnRpbWV9PC9zdHJvbmc+XG4gICAgICAgICAgICAgICAgICB7cHJvcHMuZGF0YSA/IChcbiAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgIHtwcm9wcy5kYXRhLm1hcCgoZGF0YSwgaSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17aX0gc3R5bGU9e3sgY29sb3I6IGRhdGEuc2VyaWVzLm9wdGlvbnMuc3Ryb2tlU3R5bGUgfX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtkYXRhLnZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgLz5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgc2VyaWVzPXtbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBUUyxcbiAgICAgICAgICAgICAgICByOiAyNTUsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiA0LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXX1cbiAgICAgICAgICAvPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgPGlucHV0IGlkPXtpZCtcImlucHV0XCJ9IHR5cGU9XCJyYW5nZVwiIG1pbj17MX0gbWF4PXsxMDB9IGRlZmF1bHRWYWx1ZT17MTB9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB0aGlzLnNldFN0YXRlKHttaWxsaXNQZXJQaXhlbDogZS50YXJnZXQudmFsdWV9KX0+XG4gICAgICAgIDwvaW5wdXQ+XG5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyB2YXIgdHMxID0gdGhpcy5yZWZzLmNoYXJ0LmFkZFRpbWVTZXJpZXMoe1xuICAgIC8vICAgc3Ryb2tlU3R5bGU6ICdyZ2JhKDAsIDI1NSwgMCwgMSknLFxuICAgIC8vICAgZmlsbFN0eWxlOiAncmdiYSgwLCAyNTUsIDAsIDAuMiknLFxuICAgIC8vICAgbGluZVdpZHRoOiA0LFxuICAgIC8vIH0pO1xuXG4gICAgLy8gdGhpcy5yZWZzLmNoYXJ0LmFkZFRpbWVTZXJpZXMoVFMyLCB7XG4gICAgLy8gICBzdHJva2VTdHlsZTogeyByOiAyNTUgfSxcbiAgICAvLyAgIGZpbGxTdHlsZTogeyByOiAyNTUsIGE6IDAuNSB9LFxuICAgIC8vICAgbGluZVdpZHRoOiA0LFxuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5kYXRhR2VuZXJhdG9yID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB0aW1lcyBzbGlnaHRseSBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyB0aW1lICs9IDEwMDA7XG5cbiAgICAgIC8vIHRzMS5hcHBlbmQodGltZSwgTWF0aC5yYW5kb20oKSk7XG4gICAgICAvLyBUUzIuYXBwZW5kKHRpbWUsIE1hdGgucmFuZG9tKCkpO1xuICAgICAgVFMuYXBwZW5kKHRpbWUsIE1hdGgucmFuZG9tKCkpO1xuICAgIH0sIDUwMCk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuZGF0YUdlbmVyYXRvcik7XG4gIH1cbn1cblxuU21vb3RoaWUuZGVmYXVsdFByb3BzID0ge307XG5cblNtb290aGllLnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbXBvbmVudCBpbiBEYXNoIGNhbGxiYWNrc1xuICAgICAqL1xuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogQSBsYWJlbCB0aGF0IHdpbGwgYmUgcHJpbnRlZCB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZGlzcGxheWVkIGluIHRoZSBpbnB1dFxuICAgICAqL1xuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gICAgLyoqXG4gICAgICogRGFzaC1hc3NpZ25lZCBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgYW55IG9mIHRoZVxuICAgICAqIHByb3BlcnRpZXMgY2hhbmdlXG4gICAgICovXG4gICAgc2V0UHJvcHM6IFByb3BUeXBlcy5mdW5jXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/lib/components/Smoothie.react.js\n");

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Smoothie = undefined;\n\nvar _Smoothie = __webpack_require__(/*! ./components/Smoothie.react */ \"./src/lib/components/Smoothie.react.js\");\n\nvar _Smoothie2 = _interopRequireDefault(_Smoothie);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Smoothie = _Smoothie2.default; /* eslint-disable import/prefer-default-export *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllLy4vc3JjL2xpYi9pbmRleC5qcz9kNzVhIl0sIm5hbWVzIjpbIlNtb290aGllIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7Ozs7OztRQUdJQSxRLEdBQUFBLGtCLEVBSkoiLCJmaWxlIjoiLi9zcmMvbGliL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L3ByZWZlci1kZWZhdWx0LWV4cG9ydCAqL1xuaW1wb3J0IFNtb290aGllIGZyb20gJy4vY29tcG9uZW50cy9TbW9vdGhpZS5yZWFjdCc7XG5cbmV4cG9ydCB7XG4gICAgU21vb3RoaWVcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/lib/index.js\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"React\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Ntb290aGllL2V4dGVybmFsIFwiUmVhY3RcIj9jNDgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsa0NBQWtDLEVBQUUiLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiUmVhY3RcIl07IH0oKSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///react\n");

/***/ })

/******/ });